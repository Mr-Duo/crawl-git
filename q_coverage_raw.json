{
    "language": "Python",
    "domain": [],
    "author": "Grizzlazy",
    "contributors": [
        "Grizzlazy"
    ],
    "issues": [],
    "commits": [
        {
            "sha": "1b26a2e870a91e523ea9bbe4211d2c7bfa892c2e",
            "committer": "Grizzlazy",
            "msg": "first commit",
            "date": "01/05/24T16:37:57",
            "modified_files": [],
            "parents": []
        },
        {
            "sha": "f1dbf0890a42cf9608170dac5205f6b5fbe446b0",
            "committer": "Grizzlazy",
            "msg": "first commit",
            "date": "01/05/24T16:41:10",
            "modified_files": [
                {
                    "name": "branch_and_bound.py",
                    "type": "ADD",
                    "added": 145,
                    "deleted": 0,
                    "loc": 87,
                    "source": "import numpy as np\nfrom scipy.optimize import linprog\nimport math\n\n# **Function \"isInteger(x)\"**\ndef isInteger(x):\n    \"\"\"\n    As for a vector x,check if it contains only integer values:\n    return the boolean value True and the None, i.e., [True,None] when the values are all integer\n    return False and the index of the noninteger value in x, i.e., [False,index]\n\n    \"\"\"\n    xx = np.array(x)\n    dist = np.array(abs(np.rint(xx)-xx))\n    for xx in dist:\n        if float(xx).is_integer() == False:\n            dist[dist == 0] = np.nan\n            return (False, np.nanargmin(dist))\n    return (True, None)\n\n\n# **Class \"Node\"**\nclass Node:\n    \"\"\"\n    This class models a node in the branch and bound algorithm.\n    x: the solution in node\n    z: the value of node\n    status: the status of the node, if this node is availabe\n\n    \"\"\"\n    def __init__(self, x, z, bounds, status):\n        self.x = x\n        self.z = z\n        self.bounds = bounds\n        self.status = status\n\n# Definition of the integer LP problem\n\n#==========assignment 8.1 ====================\nc = np.array([10, 20])\nA = np.array([[5, 8], [1, 0], [0, 1]])\nb = np.array([60, 8, 4])\n\n\n#=========assignment 8.2 ====================\n'''\nc = np.array([2,3,1,2])\nA = np.array([[5,2,1,1],[2,6,10,8],[1,1,1,1],[2,2,3,3],[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]])\nb = np.array([15,60,8,16,3,7,5,5])\n'''\n\nA_eq = None\nb_eq = None\nn = len(c)\n\n# two ways to initialize bounds automatically\n\n# bounds=np.full((n,2),(0,None))\nbounds = [[0, None] for _ in range(n)]\n\n\n# **Initialization of the branch-and-bound algorithm**\n\n\"\"\"\nInitialization of the branch-and-bound algorithm\n\nwe have three main input parameters, i.e., node, bestnode, iteration\nnode: the node we need to proceed\nbestnode: is used to store the best solution of the branch-and-bound algorithm\niteration: the iteration of processing node\n\n\"\"\"\n# Initializing the node\ninit_res = linprog(-c, A, b, A_eq, b_eq)\nx = init_res.x\nz = init_res.fun\nstatus = init_res.status\nnode = Node(x, z, bounds, status)\n\n# Initialize the bestnode\nbstnode_status = 0\nbestnode = Node([0, 0], 0, bounds, bstnode_status)\n\n# Initialize the iteration\niteration = 0\n\n# Branch-and-Bound recursive processing\ndef branch_bound(node, bestnode, iteration):\n    # decide the node is available or not\n    if node.status != 0:\n        return (bestnode,iteration)\n\n    # decide update the best solution or not\n    if node.z < bestnode.z:\n        (isIntegerOrNot,splitIndex) = isInteger(node.x)\n\n        # decide if the solution is integer\n        if isIntegerOrNot is True:\n            # update the bestnode\n            bestnode = node\n            # return the bestnode\n            return (bestnode, iteration)\n        else:\n            # split the node to find the bestnode\n            # choose a functional variable to split node\n            spValue = node.x[splitIndex]\n            # one child with conditional constraints x<=lowbound\n            lowbound = np.floor(spValue)\n            boundsL = np.array(node.bounds)\n            boundsL[splitIndex] = [0, lowbound]\n            # process the child node and insert them into the <node> to find the bestnode\n            resL = linprog(-c, A, b, A_eq, b_eq, boundsL)\n            nodeL = Node(resL.x, resL.fun, boundsL, resL.status)\n            iteration = iteration+1\n            print(\"Iteration number is: \"+str(iteration) + \"\\nProcessed node: Solution x:{0}, Value:{1}, Bounds:{2}\".format(nodeL.x, -nodeL.z, boundsL) + \"\\nSplit on x_\"+str(splitIndex+1))\n            if nodeL.z <= bestnode.z:\n                # start the recursive processing\n                (bestnode, iteration) = branch_bound(nodeL, bestnode, iteration)\n            else:\n                # one child with conditional constraints x>=upbound\n                upbound = np.ceil(spValue)\n                boundsR = np.array(node.bounds)\n                boundsR[splitIndex] = [upbound, None]\n                # process the child node and insert them into the <node> to find the bestnode\n                resR = linprog(-c, A, b, A_eq, b_eq, boundsR)\n                nodeR = Node(resR.x, resR.fun, boundsR, resR.status)\n                iteration = iteration + 1\n                print(\"Iteration number is: \"+str(iteration)+ \"\\nProcessed node: Solution x:{0}, Value:{1}, Bounds:{2}\".format(nodeR.x, -nodeR.z, boundsR)+\"\\nSplit on x_\"+str(splitIndex+1))\n                if nodeR.z <= bestnode.z:\n                    # start the recursive processing\n                    (bestnode, iteration) = branch_bound(nodeR, bestnode, iteration)\n    else:\n        # return the bestnode\n        return(bestnode, iteration)\n    # return the bestnode\n    return (bestnode, iteration)\n\n\n# **Final messages to the users**\n\n# print(\"Original node: x: {0}, Value:{1}, Bounds:{2}\".format(node.x,node.z,node.bounds))\n# print(\"Optimal solution x:{0}, Value:{1}, Bounds:{2}\".format(bestnode.x,-bestnode.z, bestnode.bounds))\n\n(bestnode, iteration) = branch_bound(node, bestnode, iteration)\nprint(\"\\nAn integer solution is found by improvement!\\n\")"
                },
                {
                    "name": "data.py",
                    "type": "ADD",
                    "added": 72,
                    "deleted": 0,
                    "loc": 56,
                    "source": "import math\n\nfile_name_csv = \"Data/N=10_W=10_H=8_normal_0.csv\"\n\nN = 10  # number of targets\nW = 10  # width\nH = 8   # height\nR = 3  # radius of sensor\n\ndef read_data(path):\n    coordinates = []\n    demand = []\n    with open(path, 'r') as f:\n        # Read the header line\n        header = f.readline()\n\n        for _ in range(N):\n            line = f.readline().strip().split(',')\n            x, y, q = map(float, line)\n            coordinates.append((x, y))\n            demand.append(int(q))\n\n    return coordinates, demand\n\ndef get_distances(X, Y):\n    return math.sqrt(pow(X[0]-Y[0], 2)+pow(X[1]-Y[1], 2))\n\ndef find_positions(coordinates):\n    unique_positions = set()\n    targetted = []\n    check = [0]*N\n    isolation = []\n    for i in range(len(coordinates)-1):\n        for j in range(i+1, len(coordinates)):\n            if get_distances(coordinates[i], coordinates[j]) <= 2*R:\n                check[i]+=1\n                check[j]+=1\n                \n                midpoint = ((coordinates[i][0] + coordinates[j][0]) / 2, (coordinates[i][1] + coordinates[j][1]) / 2)\n                angle = math.atan2(coordinates[j][1] - coordinates[i][1], coordinates[j][0] - coordinates[i][0])\n\n                x_p1 = round(midpoint[0] + R * math.cos(angle + math.pi/2), 6)\n                y_p1 = round(midpoint[1] + R * math.sin(angle + math.pi/2), 6)\n\n                x_p2 = round(midpoint[0] - R * math.cos(angle + math.pi/2), 6)\n                y_p2 = round(midpoint[1] - R * math.sin(angle + math.pi/2), 6)\n\n                if 0 <= x_p1 <= W and 0 <= y_p1 <= H:\n                    unique_positions.add((x_p1, y_p1))\n                    targetted.append([i, j])\n                if 0 <= x_p2 <= W and 0 <= y_p2 <= H:\n                    unique_positions.add((x_p2, y_p2))\n                    targetted.append([i, j])\n    for i in range(len(coordinates)):\n        if check[i] == 0: isolation.append(i)\n\n    for i in range(len(list(unique_positions))):\n        for j in range(len(coordinates)):\n            if j not in targetted[i] and j not in isolation: \n                if get_distances(list(unique_positions)[i], coordinates[j]) <= R:\n                    targetted[i].append(j)\n    \n    a = []\n    for j in range(len(coordinates)):\n        temp = [0]*len(list(unique_positions))\n        a.append(temp)\n        for i in range(len(list(unique_positions))):\n            if j in targetted[i]:\n                a[j][i] = 1\n    \n    return list(unique_positions), a, isolation\n\n"
                },
                {
                    "name": "main.py",
                    "type": "ADD",
                    "added": 111,
                    "deleted": 0,
                    "loc": 65,
                    "source": "import data\nimport simplex_method\nimport queue\nimport math\nimport numpy as np\n\nfile_name_csv = \"Data/N=10_W=10_H=8_normal_0.csv\"\n\nT = [] #Target\nQ = [] #Demand\nI = [] #Target isolated\nP = [] #Good position for placing sensors\nx = [] #Number of sensors in P\na = [] #Sensor j cover by position P_i\nT, Q = data.read_data(file_name_csv)\n\nP, a, I = data.find_positions(T)\n\nc = [1]*len(P)\nQ_0 = max(Q) #Highest demand\n\n\ndef isInteger(x):\n    \"\"\"\n    As for a vector x,check if it contains only integer values:\n    return the boolean value True and the None, i.e., [True,None] when the values are all integer\n    return False and the index of the noninteger value in x, i.e., [False,index]\n\n    \"\"\"\n    xx = np.array(x)\n    dist = np.array(abs(np.rint(xx)-xx))\n    for xx in dist:\n        if float(xx).is_integer() == False:\n            dist[dist == 0] = np.nan\n            return (False, np.nanargmin(dist))\n    return (True, None)\n\ndef create_subproblem(A, b, c, Q0, solution):\n    # Create subproblem with rounded down constraints\n    subproblem_floor = {\n        'A': np.vstack([A, np.eye(len(c))]),\n        'b': np.concatenate([b, np.floor(solution)]),\n        'c': c,\n        'Q0': Q0\n    }\n\n    # Create subproblem with rounded up constraints\n    subproblem_ceil = {\n        'A': np.vstack([A, -np.eye(len(c))]),\n        'b': np.concatenate([b, -np.ceil(solution)]),\n        'c': c,\n        'Q0': Q0\n    }\n\n    return subproblem_floor, subproblem_ceil\n\ndef branch_and_bound(A, b, c, Q0):\n    # Initialize priority queue\n    pq = queue.PriorityQueue()\n    tolerance=1e-6\n    max_iterations=1000\n    initial_problem = {'A': A, 'b': b, 'c': c, 'Q0': Q0}\n    pq.put((0, initial_problem))\n\n    best_solution = None\n    best_value = float('inf')\n\n    iterations = 0\n    while not pq.empty() and iterations < max_iterations:\n        # Pop problem with the best lower bound\n        _, current_problem = pq.get()\n\n        # Solve the current problem\n        current_solution, current_value = simplex_method.simplex_method(current_problem['A'], current_problem['b'], current_problem['c'], current_problem['Q0'])\n\n        # Update the best solution\n        if np.all(current_value < best_value):\n            best_solution = current_solution\n            best_value = current_value\n\n        # Check if the current solution is integer\n        if all(np.abs(np.round(current_solution) - current_solution) < tolerance):\n            continue  # Skip if the solution is integer\n\n        # Branching - Create two subproblems\n        subproblem_floor, subproblem_ceil = create_subproblem(current_problem['A'], current_problem['b'], current_problem['c'], current_problem['Q0'], np.floor(current_solution))\n        subproblem_ceil['Q0'] = current_solution\n        subproblem_floor['Q0'] = current_solution\n        pq.put((current_value, subproblem_floor))\n        pq.put((current_value, subproblem_ceil))\n\n        iterations += 1\n\n    return best_solution, best_value\n\nx,  optimal_solution = branch_and_bound(a, Q, c, Q_0)\n\nprint(x)\nprint(optimal_solution)\n\n\n\n\n\n\n    \n\n\n\n\n\n"
                },
                {
                    "name": "simplex_method.py",
                    "type": "ADD",
                    "added": 64,
                    "deleted": 0,
                    "loc": 47,
                    "source": "import numpy as np\nimport time\n\ndef simplex_method(A, b, c, Q0):\n    A = np.array(A)\n    m, n = A.shape\n\n    # Add slack variables to convert inequalities to equalities\n    A_extended = np.hstack((A, np.eye(m)))\n    c_extended = np.concatenate((c, np.zeros(m)))\n\n    # Create the tableau\n    tableau = np.vstack((np.hstack((np.zeros(1), -c_extended, 0)), np.column_stack((b, A_extended, Q0*np.ones(m)))))\n    while np.any(tableau[0, 1:] < 0):\n        # Find the entering variable (pivot column)\n        pivot_col = np.argmin(tableau[0, 1:]) + 1\n\n        # Find the leaving variable (pivot row)\n        # Thay \u0111\u1ed5i c\u00e1ch t\u00ednh ratios\n        ratios = np.where(tableau[1:, pivot_col] > 0, tableau[1:, 0] / tableau[1:, pivot_col], np.inf)\n\n        pivot_row = np.argmin(ratios) + 1\n\n        # Pivot element\n        pivot = tableau[pivot_row, pivot_col]\n\n        # Update the tableau\n        tableau[pivot_row, :] /= pivot\n        for i in range(tableau.shape[0]):\n            if i != pivot_row:\n                tableau[i, :] -= tableau[i, pivot_col] * tableau[pivot_row, :]\n    # Optimal solution and optimal value\n    optimal_solution = tableau[1:, 0]\n    optimal_value = tableau[0, 0]\n\n    return optimal_solution, optimal_value\n'''\nA = [\n    [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1],\n    [1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0],\n    [0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],\n    [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1],\n    [1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0],\n    [0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1],\n    [0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1]\n]\n\n# B\u00e0i to\u00e1n t\u1ed1i \u01b0u\nb = [5, 1, 3, 5, 5, 3, 3, 2, 1, 4]\nc = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n\nQ0 = 5\n\n\n# Gi\u1ea3i b\u00e0i to\u00e1n t\u1ed1i \u01b0u\noptimal_solution, optimal_value = simplex_method(A, b, c, Q0)\nnp.set_printoptions(precision=6, suppress=True)\n# In k\u1ebft qu\u1ea3\nprint(\"Optimal Solution:\", optimal_solution)\nprint(\"Optimal Value:\", optimal_value)'''\n\n"
                },
                {
                    "name": "test.py",
                    "type": "ADD",
                    "added": 59,
                    "deleted": 0,
                    "loc": 43,
                    "source": "import math\nimport numpy as np\n\ndef get_pivot_position(tableau):\n    z = tableau[-1]\n    column = next(i for i, x in enumerate(z[:-1]) if x > 0)\n    \n    restrictions = []\n    for eq in tableau[:-1]:\n        el = eq[column]\n        restrictions.append(math.inf if el <= 0 else eq[-1] / el)\n        \n    if (all([r == math.inf for r in restrictions])):\n        raise Exception(\"Linear program is unbounded.\")\n\n    row = restrictions.index(min(restrictions))\n    return row, column\n\ndef pivot_step(tableau, pivot_position):\n    new_tableau = [[] for eq in tableau]\n    \n    i, j = pivot_position\n    pivot_value = tableau[i][j]\n    new_tableau[i] = np.array(tableau[i]) / pivot_value\n    \n    for eq_i, eq in enumerate(tableau):\n        if eq_i != i:\n            multiplier = np.array(new_tableau[i]) * tableau[eq_i][j]\n            new_tableau[eq_i] = np.array(tableau[eq_i]) - multiplier\n   \n    return new_tableau\n\ndef is_basic(column):\n    return sum(column) == 1 and len([c for c in column if c == 0]) == len(column) - 1\n\ndef get_solution(tableau):\n    columns = np.array(tableau).T\n    solutions = []\n    for column in columns[:-1]:\n        solution = 0\n        if is_basic(column):\n            one_index = column.tolist().index(1)\n            solution = columns[-1][one_index]\n        solutions.append(solution)\n        \n    return solutions\n\ndef simplex(c, A, b):\n    tableau = to_tableau(c, A, b)\n\n    while can_be_improved(tableau):\n        pivot_position = get_pivot_position(tableau)\n        tableau = pivot_step(tableau, pivot_position)\n\n    return get_solution(tableau)\n\n\nsolution = simplex(c, A, b)\nprint('solution: ', solution)"
                }
            ],
            "parents": [
                "1b26a2e870a91e523ea9bbe4211d2c7bfa892c2e"
            ]
        },
        {
            "sha": "cd8f4733b623a5058f5b337fb1b35cbc2566c200",
            "committer": "Grizzlazy",
            "msg": "update",
            "date": "01/05/24T17:50:38",
            "modified_files": [
                {
                    "name": "main.py",
                    "type": "MODIFY",
                    "added": 40,
                    "deleted": 63,
                    "loc": 72,
                    "source": "import data\nimport simplex_method\nimport queue\nimport math\nimport numpy as np\nimport copy\n\nfile_name_csv = \"Data/N=10_W=10_H=8_normal_0.csv\"\n\nT = [] #Target\nQ = [] #Demand\nI = [] #Target isolated\nP = [] #Good position for placing sensors\nx = [] #Number of sensors in P\na = [] #Sensor j cover by position P_i\nT, Q = data.read_data(file_name_csv)\n\nP, a, I = data.find_positions(T)\n\nc = [1]*len(P)\nQ_0 = max(Q) #Highest demand\nepsilon = (-1)*0.000001\n\ndef isInteger(x):\n    xx = np.array(x)\n    dist = np.array(abs(np.rint(xx) - xx))\n    for i, val in enumerate(dist):\n        if not float(val).is_integer():\n            dist[dist == 0] = np.nan\n            return False, np.nanargmin(dist)\n    return True, None\n\ndef create_subproblem(A, b, c, Q0, solution):\n    # Create subproblem with rounded down constraints\n    index = isInteger(solution)[1]\n    \n    subproblem_floor = {\n        'A': np.vstack([A, [0]*(index)+[1]+[0]*(len(P)-index-1)]),\n        'b': np.concatenate([b, [int(solution[index])]]),\n        'c': c,\n        'Q0': Q0\n    }\n    # Create subproblem with rounded up constraints\n    subproblem_ceil = {\n        'A': np.vstack([A, [0]*(index)+[-1]+[0]*(len(P)-index-1)]),\n        'b': np.concatenate([b, [-(int(solution[index])+1)]]),\n        'c': c,\n        'Q0': Q0\n    }\n\n    return subproblem_floor, subproblem_ceil\n\n\ndef branch_and_bound(A, b, c, Q0):\n    # Initialize priority queue\n    q = queue.Queue()\n    iteration = 100\n    best_value = 1e6\n    best_solution = []\n    initial_problem = {'A': A, 'b': b, 'c': c, 'Q0': Q0}\n    q.put(initial_problem)\n    while not q.empty() and iteration > 0:\n        current_problem = q.get()\n        flag, current_solution, current_value = simplex_method.simplex_method(current_problem['A'], current_problem['b'], current_problem['c'], current_problem['Q0'])\n        if not flag: continue\n        if isInteger(current_solution)[0]:\n            if current_value - best_value < epsilon:\n                best_solution = copy.deepcopy(current_solution)\n                best_value = current_value\n            else: \n                continue\n        else:\n            if current_value - best_value > 1e-6:\n                continue\n            subproblem_floor, subproblem_ceil = create_subproblem(current_problem['A'], current_problem['b'], current_problem['c'], current_problem['Q0'], current_solution)\n            q.put(subproblem_floor)\n            q.put(subproblem_ceil)\n        print(1000 - iteration)\n        print(current_value)\n        print(current_solution)\n        iteration -=1\n\n    return best_solution, best_value\n\nx,  optimal_solution = branch_and_bound(a, Q, c, Q_0)\n\nprint(x)\nprint(optimal_solution)"
                },
                {
                    "name": "simplex_method.py",
                    "type": "MODIFY",
                    "added": 7,
                    "deleted": 2,
                    "loc": 49,
                    "source": "import numpy as np\nimport time\n\ndef simplex_method(A, b, c, Q0):\n    A = np.array(A)\n    m, n = A.shape\n\n    # Add slack variables to convert inequalities to equalities\n    A_extended = np.hstack((A, np.eye(m)))\n    c_extended = np.concatenate((c, np.zeros(m)))\n\n    # Create the tableau\n    tableau = np.vstack((np.hstack((np.zeros(1), -c_extended, 0)), np.column_stack((b, A_extended, Q0*np.ones(m)))))\n\n    while np.any(tableau[0, 1:] < 0):\n        # Find the entering variable (pivot column)\n        pivot_col = np.argmin(tableau[0, 1:]) + 1\n\n        # Find the leaving variable (pivot row)\n        ratios = np.where(tableau[1:, pivot_col] > 0, tableau[1:, 0] / tableau[1:, pivot_col], np.inf)\n\n        # Check for infeasibility\n        if np.all(ratios == np.inf):\n            return False, None, None\n\n        pivot_row = np.argmin(ratios) + 1\n\n        # Pivot element\n        pivot = tableau[pivot_row, pivot_col]\n\n        # Update the tableau\n        tableau[pivot_row, :] /= pivot\n        for i in range(tableau.shape[0]):\n            if i != pivot_row:\n                tableau[i, :] -= tableau[i, pivot_col] * tableau[pivot_row, :]\n\n    # Optimal solution and optimal value\n    optimal_solution = tableau[1:, 0]\n    optimal_value = tableau[0, 0]\n\n    return True, optimal_solution, optimal_value\n'''\nA = [\n    [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1],\n    [1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0],\n    [0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],\n    [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1],\n    [1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0],\n    [0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1],\n    [0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1]\n]\n\n# B\u00e0i to\u00e1n t\u1ed1i \u01b0u\nb = [5, 1, 3, 5, 5, 3, 3, 2, 1, 4]\nc = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n\nQ0 = 5\n\n\n# Gi\u1ea3i b\u00e0i to\u00e1n t\u1ed1i \u01b0u\noptimal_solution, optimal_value = simplex_method(A, b, c, Q0)\nnp.set_printoptions(precision=6, suppress=True)\n# In k\u1ebft qu\u1ea3\nprint(\"Optimal Solution:\", optimal_solution)\nprint(\"Optimal Value:\", optimal_value)'''\n\n"
                },
                {
                    "name": "tempCodeRunnerFile.py",
                    "type": "ADD",
                    "added": 5,
                    "deleted": 0,
                    "loc": 5,
                    "source": "    subproblem_floor, subproblem_ceil = create_subproblem(current_problem['A'], current_problem['b'], current_problem['c'], current_problem['Q0'], np.floor(current_solution))\n            subproblem_ceil['Q0'] = current_solution\n            subproblem_floor['Q0'] = current_solution\n            pq.put((current_value, subproblem_floor))\n            pq.put((current_value, subproblem_ceil))"
                }
            ],
            "parents": [
                "f1dbf0890a42cf9608170dac5205f6b5fbe446b0"
            ]
        },
        {
            "sha": "1c6d0615ce5c56c4a73cfa15ea6cbf3f920d6ef6",
            "committer": "Grizzlazy",
            "msg": "commit",
            "date": "01/05/24T18:09:44",
            "modified_files": [
                {
                    "name": "main.py",
                    "type": "MODIFY",
                    "added": 4,
                    "deleted": 5,
                    "loc": 72,
                    "source": "import data\nimport simplex_method\nimport queue\nimport math\nimport numpy as np\nimport copy\n\nfile_name_csv = \"Data/N=10_W=10_H=8_uniform_0.csv\"\n\nT = [] #Target\nQ = [] #Demand\nI = [] #Target isolated\nP = [] #Good position for placing sensors\nx = [] #Number of sensors in P\na = [] #Sensor j cover by position P_i\nT, Q = data.read_data(file_name_csv)\n\nP, a, I = data.find_positions(T)\n\nc = [1]*len(P)\nQ_0 = max(Q) #Highest demand\nepsilon = (-1)*0.000001\n\ndef isInteger(x):\n    xx = np.array(x)\n    dist = np.array(abs(np.rint(xx) - xx))\n    for i, val in enumerate(dist):\n        if not float(val).is_integer():\n            dist[dist == 0] = np.nan\n            return False, np.nanargmin(dist)\n    return True, None\n\ndef create_subproblem(A, b, c, Q0, solution):\n    # Create subproblem with rounded down constraints\n    index = isInteger(solution)[1]\n    \n    subproblem_floor = {\n        'A': np.vstack([A, [0]*(index)+[1]+[0]*(len(P)-index-1)]),\n        'b': np.concatenate([b, [int(solution[index])]]),\n        'c': c,\n        'Q0': Q0\n    }\n    # Create subproblem with rounded up constraints\n    subproblem_ceil = {\n        'A': np.vstack([A, [0]*(index)+[-1]+[0]*(len(P)-index-1)]),\n        'b': np.concatenate([b, [-(int(solution[index])+1)]]),\n        'c': c,\n        'Q0': Q0\n    }\n\n    return subproblem_floor, subproblem_ceil\n\n\ndef branch_and_bound(A, b, c, Q0):\n    q = queue.Queue()\n    iteration = 1e6\n    best_value = 1e6\n    best_solution = []\n    initial_problem = {'A': A, 'b': b, 'c': c, 'Q0': Q0}\n    q.put(initial_problem)\n    while not q.empty() and iteration > 0:\n        current_problem = q.get()\n        flag, current_solution, current_value = simplex_method.simplex_method(current_problem['A'], current_problem['b'], current_problem['c'], current_problem['Q0'])\n        if not flag: continue\n        if isInteger(current_solution)[0]:\n            if current_value - best_value < epsilon:\n                best_solution = copy.deepcopy(current_solution)\n                best_value = current_value\n            else: \n                continue\n        else:\n            if current_value - best_value > 0.01:\n                continue\n            subproblem_floor, subproblem_ceil = create_subproblem(current_problem['A'], current_problem['b'], current_problem['c'], current_problem['Q0'], current_solution)\n            q.put(subproblem_floor)\n            q.put(subproblem_ceil)\n        print('---------',iteration, '-----------')\n        print(current_value)\n        print(current_solution)\n        iteration -=1\n\n    return best_solution, best_value\n\nx,  optimal_solution = branch_and_bound(a, Q, c, Q_0)\n\nprint(x)\nprint(optimal_solution)"
                },
                {
                    "name": "simplex_method.py",
                    "type": "MODIFY",
                    "added": 0,
                    "deleted": 8,
                    "loc": 49,
                    "source": "import numpy as np\nimport time\n\ndef simplex_method(A, b, c, Q0):\n    A = np.array(A)\n    m, n = A.shape\n\n    A_extended = np.hstack((A, np.eye(m)))\n    c_extended = np.concatenate((c, np.zeros(m)))\n\n    tableau = np.vstack((np.hstack((np.zeros(1), -c_extended, 0)), np.column_stack((b, A_extended, Q0*np.ones(m)))))\n\n    while np.any(tableau[0, 1:] < 0):\n        pivot_col = np.argmin(tableau[0, 1:]) + 1\n\n        ratios = np.where(tableau[1:, pivot_col] > 0, tableau[1:, 0] / tableau[1:, pivot_col], np.inf)\n\n        if np.all(ratios == np.inf):\n            return False, None, None\n\n        pivot_row = np.argmin(ratios) + 1\n\n        pivot = tableau[pivot_row, pivot_col]\n\n        tableau[pivot_row, :] /= pivot\n        for i in range(tableau.shape[0]):\n            if i != pivot_row:\n                tableau[i, :] -= tableau[i, pivot_col] * tableau[pivot_row, :]\n\n    optimal_solution = tableau[1:, 0]\n    optimal_value = tableau[0, 0]\n\n    return True, optimal_solution, optimal_value\n'''\nA = [\n    [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1],\n    [1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0],\n    [0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],\n    [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1],\n    [1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0],\n    [0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1],\n    [0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1]\n]\n\n# B\u00e0i to\u00e1n t\u1ed1i \u01b0u\nb = [5, 1, 3, 5, 5, 3, 3, 2, 1, 4]\nc = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n\nQ0 = 5\n\n\n# Gi\u1ea3i b\u00e0i to\u00e1n t\u1ed1i \u01b0u\noptimal_solution, optimal_value = simplex_method(A, b, c, Q0)\nnp.set_printoptions(precision=6, suppress=True)\n# In k\u1ebft qu\u1ea3\nprint(\"Optimal Solution:\", optimal_solution)\nprint(\"Optimal Value:\", optimal_value)'''\n\n"
                }
            ],
            "parents": [
                "cd8f4733b623a5058f5b337fb1b35cbc2566c200"
            ]
        },
        {
            "sha": "519530794c367981a6c91978243a7658c9482567",
            "committer": "Grizzlazy",
            "msg": "Update",
            "date": "01/07/24T16:41:39",
            "modified_files": [
                {
                    "name": "data.py",
                    "type": "MODIFY",
                    "added": 14,
                    "deleted": 11,
                    "loc": 56,
                    "source": "import math\n\nfile_name_csv = \"Data/N=10_W=10_H=8_normal_0.csv\"\n\nN = 10  # number of targets\nW = 30  # width\nH = 40  # height\nR = 3  # radius of sensor\n\ndef read_data(path):\n    coordinates = []\n    demand = []\n    with open(path, 'r') as f:\n        # Read the header line\n        header = f.readline()\n\n        for _ in range(N):\n            line = f.readline().strip().split(',')\n            x, y, q = map(float, line)\n            coordinates.append((x, y))\n            demand.append(int(q))\n\n    return coordinates, demand\n\ndef get_distances(X, Y):\n    return math.sqrt(pow(X[0]-Y[0], 2)+pow(X[1]-Y[1], 2))\n\ndef find_positions(coordinates):\n    unique_positions = set()\n\n    check = [0]*N\n    for i in range(len(coordinates)-1):\n        for j in range(i+1, len(coordinates)):\n            if get_distances(coordinates[i], coordinates[j]) <= 2*R:\n                check[i]+=1\n                check[j]+=1\n                \n                midpoint = ((coordinates[i][0] + coordinates[j][0]) / 2, (coordinates[i][1] + coordinates[j][1]) / 2)\n                angle = math.atan2(coordinates[j][1] - coordinates[i][1], coordinates[j][0] - coordinates[i][0])\n\n                x_p1 = round(midpoint[0] + R * math.cos(angle + math.pi/2), 6)\n                y_p1 = round(midpoint[1] + R * math.sin(angle + math.pi/2), 6)\n\n                x_p2 = round(midpoint[0] - R * math.cos(angle + math.pi/2), 6)\n                y_p2 = round(midpoint[1] - R * math.sin(angle + math.pi/2), 6)\n\n                if 0 <= x_p1 <= W and 0 <= y_p1 <= H:\n                    unique_positions.add((x_p1, y_p1))\n                if 0 <= x_p2 <= W and 0 <= y_p2 <= H:\n                    unique_positions.add((x_p2, y_p2))\n\n    for i in range(len(coordinates)):\n        if check[i] == 0: \n            unique_positions.add((coordinates[i][0], coordinates[i][1]))\n    \n    targetted = []\n    for i in range(len(list(unique_positions))):\n        temp = []\n        targetted.append(temp)\n\n    for i in range(len(list(unique_positions))):\n        for j in range(len(coordinates)):\n            if get_distances(list(unique_positions)[i], coordinates[j]) <= R:\n                targetted[i].append(j)\n    \n    a = []\n    for j in range(len(coordinates)):\n        temp = [0]*len(list(unique_positions))\n        a.append(temp)\n        for i in range(len(list(unique_positions))):\n            if j in targetted[i]:\n                a[j][i] = 1\n    \n    return list(unique_positions), a\n\n"
                },
                {
                    "name": "main.py",
                    "type": "MODIFY",
                    "added": 58,
                    "deleted": 34,
                    "loc": 86,
                    "source": "import data\nimport simplex_method\nimport queue\nimport math\nimport numpy as np\nimport copy\nfrom scipy.optimize import linprog\n\nfile_name_csv = \"Data/N=10_W=30_H=40_normal_0.csv\"\n\nT = [] #Target\nQ = [] #Demand\nI = [] #Target isolated\nP = [] #Good position for placing sensors\nx = [] #Number of sensors in P\na = [] #Sensor j cover by position P_i\nT, Q = data.read_data(file_name_csv)\n\nP, a = data.find_positions(T)\n\nc = [1]*len(P)\nQ_0 = max(Q) #Highest demand\nepsilon = (-1)*0.000001\n\ndef isInteger(x):\n    for i in range (len(P)):\n        if not float(x[i]).is_integer():\n            index = i\n            return False, index\n    return True, None\n\ndef create_subproblem(A, b, c, solution):\n    # Create subproblem with rounded down constraints\n    index = isInteger(solution)[1]\n    floor_constraint = np.zeros(len(P))\n    floor_constraint[index] = 1\n\n    subproblem_floor = {\n        'A': np.vstack([A, floor_constraint]),\n        'b': np.concatenate([b, [int(solution[index]) + 1]]),\n        'c': c\n    }\n\n    # Create subproblem with rounded up constraints\n    ceil_constraint = -floor_constraint\n    subproblem_ceil = {\n        'A': np.vstack([A, ceil_constraint]),\n        'b': np.concatenate([b, [-int(solution[index])]]),\n        'c': c\n    }\n\n    return subproblem_floor, subproblem_ceil\n\ndef simplex_method1(a, Q, c):\n    A = -1 * np.array(a)  # Assuming 'a' is a matrix of coefficients\n\n    # Inequality constraints RHS\n    b = -1 * np.array(Q)  # Assuming 'q' is a vector of constants\n    Q0 = max(Q)\n    # Bounds for variables\n    x0_bounds = (0, Q0)\n    bounds = [x0_bounds] * len(c)\n\n    # Solve the linear programming problem\n    result = linprog(c, A_ub=A, b_ub=b, bounds=bounds, method='highs')\n\n    if result.success:\n        optimal_solution = [round(x, 6) for x in result.x]\n        optimal_value = round(result.fun, 6)\n    else:\n        optimal_solution = None\n        optimal_value = None\n\n    return result.success, optimal_solution, optimal_value\n\ndef branch_and_bound(A, b, c):\n    q = queue.Queue()\n    iteration = 1e6\n    best_value = 1e6\n    best_solution = []\n    initial_problem = {'A': A, 'b': b, 'c': c}\n    q.put(initial_problem)\n    while not q.empty():\n        current_problem = q.get()\n        flag, current_solution, current_value = simplex_method1(current_problem['A'], current_problem['b'], current_problem['c'])\n        print(flag, current_solution)\n        if not flag: continue\n        if isInteger(current_solution)[0]:\n            if current_value - best_value < epsilon:\n                best_solution = copy.deepcopy(current_solution)\n                best_value = current_value\n        else:\n            if current_value - best_value < epsilon:\n                subproblem_floor, subproblem_ceil = create_subproblem(current_problem['A'], current_problem['b'], current_problem['c'], current_solution)\n                q.put(subproblem_floor)\n                q.put(subproblem_ceil)\n        #print('---------',iteration, '-----------')\n        print(current_value)\n        print(current_solution)\n        break\n        #iteration -=1\n    \n    if best_solution == []:\n        return False, None, None\n    return True, best_solution, best_value\n\nflag, x,  optimal_solution = branch_and_bound(a, Q, c)\n\nprint(flag)\nprint(x)\nprint(optimal_solution)"
                },
                {
                    "name": "simplex_method.py",
                    "type": "MODIFY",
                    "added": 51,
                    "deleted": 2,
                    "loc": 93,
                    "source": "import numpy as np\nimport time\n\ndef simplex_method(A, b, c, Q0):\n    A = np.array(A)\n    m, n = A.shape\n\n    # Add slack variables\n    slack_variables = np.eye(m)\n    A_extended = np.hstack((A, slack_variables))\n    c_extended = np.concatenate((c, np.zeros(m)))\n\n    # Add surplus variables\n    surplus_variables = np.eye(m)\n    A_surplus = np.hstack((A, surplus_variables))\n    \n    tableau = np.vstack((np.hstack((np.zeros(1), -c_extended, 0)), np.column_stack((b, A_surplus, Q0*np.ones(m)))))\n\n    while np.any(tableau[0, 1:] < 0):\n        pivot_col = np.argmin(tableau[0, 1:]) + 1\n\n        ratios = np.where(tableau[1:, pivot_col] > 0, tableau[1:, 0] / tableau[1:, pivot_col], np.inf)\n\n        if np.all(ratios == np.inf):\n            return False, None, None\n\n        pivot_row = np.argmin(ratios) + 1\n\n        pivot = tableau[pivot_row, pivot_col]\n\n        tableau[pivot_row, :] /= pivot\n        for i in range(tableau.shape[0]):\n            if i != pivot_row:\n                tableau[i, :] -= tableau[i, pivot_col] * tableau[pivot_row, :]\n\n    optimal_solution = tableau[1:, 0]\n    optimal_value = tableau[0, 0]\n\n    return True, optimal_solution, optimal_value\n\n\n'''\nA = [\n    [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1],\n    [1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0],\n    [0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],\n    [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1],\n    [1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0],\n    [0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1],\n    [0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1]\n]\n\n# B\u00e0i to\u00e1n t\u1ed1i \u01b0u\nb = [5, 1, 3, 5, 5, 3, 3, 2, 1, 4]\nc = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n\nQ0 = 5\n\n\n# Gi\u1ea3i b\u00e0i to\u00e1n t\u1ed1i \u01b0u\noptimal_solution, optimal_value = simplex_method(A, b, c, Q0)\nnp.set_printoptions(precision=6, suppress=True)\n# In k\u1ebft qu\u1ea3\nprint(\"Optimal Solution:\", optimal_solution)\nprint(\"Optimal Value:\", optimal_value)'''\n\n'''test = {'A': np.array([[ 1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  0.,  0.,  0.,  0.,  0.,\n         0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  1.,  0.,  0.,\n         1.,  0.,  0.,  0.,  0.,  1.,  0.,  0.,  0.,  1.,  1.],\n       [ 1.,  1.,  1.,  0.,  0.,  0.,  0.,  0.,  1.,  1.,  1.,  1.,  1.,\n         1.,  0.,  0.,  0.,  1.,  0.,  0.,  0.,  0.,  0.,  1.,  0.,  0.,\n         1.,  0.,  0.,  0.,  0.,  1.,  0.,  0.,  0.,  1.,  0.],\n       [ 0.,  0.,  1.,  0.,  0.,  0.,  0.,  0.,  1.,  1.,  0.,  0.,  0.,\n         0.,  1.,  1.,  1.,  1.,  1.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,\n         0.,  0.,  0.,  0.,  0.,  0.,  1.,  1.,  0.,  0.,  1.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  1.,  0.,  0.,  0.,\n         0.,  1.,  0.,  0.,  0.,  0.,  1.,  1.,  1.,  0.,  0.,  0.,  0.,\n         0.,  0.,  1.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  1.,  0.,  0.,  0.,  0.,  0.,  1.,  0.,  0.,  0.,\n         0.,  0.,  1.,  0.,  0.,  0.,  1.,  0.,  0.,  1.,  1.,  1.,  1.,\n         0.,  0.,  0.,  0.,  0.,  0.,  1.,  0.,  0.,  0.,  1.],\n       [ 0.,  0.,  0.,  1.,  1.,  1.,  1.,  0.,  0.,  0.,  1.,  1.,  1.,\n         1.,  0.,  0.,  1.,  1.,  1.,  0.,  1.,  1.,  1.,  1.,  0.,  1.,\n         1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  0.,  1.,  1.],\n       [ 1.,  0.,  1.,  0.,  0.,  0.,  1.,  0.,  0.,  0.,  0.,  1.,  1.,\n         0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  1.,  0.,\n         1.,  1.,  0.,  0.,  0.,  0.,  0.,  1.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  1.,  0.,  0.,  1.,  1.,  1.,  1.,  0.,  0.,  0.,\n         1.,  0.,  0.,  0.,  1.,  0.,  0.,  1.,  1.,  1.,  0.,  0.,  1.,\n         0.,  0.,  1.,  1.,  0.,  0.,  1.,  1.,  1.,  1.,  1.],\n       [ 0.,  1.,  0.,  1.,  1.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,\n         0.,  0.,  0.,  0.,  0.,  1.,  1.,  0.,  1.,  1.,  0.,  0.,  0.,\n         0.,  1.,  0.,  1.,  1.,  0.,  0.,  0.,  1.,  1.,  1.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,\n         0.,  1.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,\n         0.,  0.,  0.,  0.,  0.,  1.,  1.,  0.,  0.,  0.,  1.],\n       [-0., 1., -0., -0., -0., -0., -0., -0., -0., -0., -0., -0., -0.,\n        -0., -0., -0., -0., -0., -0., -0., -0., -0., -0., -0., -0., -0.,\n        -0., -0., -0., -0., -0., -0., -0., -0., -0., -0., -0.]]), \n        'b': np.array([5, 1, 3, 5, 5, 3, 3, 2, 1, 4, 1]), \n        'c': [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], \n        'Q0': 5}\nprint(len(test['A'][0]))\nflag, optimal_solution, optimal_value = simplex_method(test['A'], test['b'], test['c'], test['Q0'])\nprint(flag)\nprint(optimal_solution)\nprint(optimal_value)'''"
                },
                {
                    "name": "test.py",
                    "type": "MODIFY",
                    "added": 39,
                    "deleted": 58,
                    "loc": 30,
                    "source": "from scipy.optimize import linprog\nimport numpy as np\nimport data\nfile_name_csv = \"Data/N=10_W=10_H=8_normal_0.csv\"\nT, Q = data.read_data(file_name_csv)\n\nP, a, I = data.find_positions(T)\n# Objective function coefficients\nm = len(P)\nc = [1] * m\n# Inequality constraints matrix\ndef simplex_method(a, Q, c):\n    A = -1 * np.array(a)  # Assuming 'a' is a matrix of coefficients\n\n    # Inequality constraints RHS\n    b = -1 * np.array(Q)  # Assuming 'q' is a vector of constants\n    Q0 = max(Q)\n    # Bounds for variables\n    x0_bounds = (0, Q0)\n    bounds = [x0_bounds] * m\n\n    # Solve the linear programming problem\n    result = linprog(c, A_ub=A, b_ub=b, bounds=bounds, method='highs')\n\n    if result.success:\n        print(\"Optimization successfully converged.\")\n        optimal_solution = result.x\n        optimal_value = result.fun\n    else:\n        print(\"Optimization did not converge. No solution found.\")\n        optimal_solution = None\n        optimal_value = None\n\n    return result.success, optimal_solution, optimal_value\n'''\n# Optimal solution\nflag, optimal_solution, optimal_value = simplex_method(a, Q, c) \nprint(flag)\nprint(\"Optimal Solution:\", optimal_solution)\nprint(\"Optimal Value:\", optimal_value)'''\n"
                },
                {
                    "name": "test2.py",
                    "type": "ADD",
                    "added": 186,
                    "deleted": 0,
                    "loc": 111,
                    "source": "# -*- coding: utf-8 -*-\n\"\"\"\n\nEmbry-Riddle Aeronautical University\n@author: Nicolas Gachancipa\n\nDual Simplex Optimization Method\n\"\"\"\n# Imports\nimport numpy as np\nfrom numpy import concatenate as ct\n\n'''# Inputs\nz = np.array([[2, 7, 6, 5, 0, 0, 0]])\nA = np.array([[-2, 3, 5, 4, 1, 0, 0], \n              [7, 2, 6, -2, 0, 1, 0], \n              [-4, -5, 3, 2, 0, 0, 1]])\nb = np.array([[-20, 35, -15]])\nXB = [4, 5, 6]'''\n\na = [\n    [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1],\n    [1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0],\n    [0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],\n    [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1],\n    [1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0],\n    [0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1],\n    [0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1]\n]\n\n# B\u00e0i to\u00e1n t\u1ed1i \u01b0u\nb = [5, 1, 3, 5, 5, 3, 3, 2, 1, 4]\nc = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n\nQ0 = 5\n\ndef convert(A, b, c, Q0):\n    A = np.array(A)\n    m, n = A.shape\n\n    # Add slack variables\n    slack_variables = np.eye(m)\n    A_extended = np.hstack((A, slack_variables))\n    c_extended = np.concatenate((c, np.zeros(m)))\n\n    # Add surplus variables\n    surplus_variables = np.eye(m)\n    A_surplus = np.hstack((A, surplus_variables))\n    XB = []\n    for i in range (m):\n        XB.append(len(c_extended)-m+i)\n    tableau = np.vstack((np.hstack((np.zeros(1), -c_extended, 0)), np.column_stack((b, A_surplus, Q0*np.ones(m)))))\n    return tableau\n# Function to update tableau using matrix operations.\nprint(convert(a, b,c, Q0))\nA, z, XB = convert(a, c)\n\ndef update_tableau(tableau, basis):\n    \n    # Create new tableau.\n    new_tableau = []\n    \n    # Update each row (including z)\n    for row_idx in range(len(basis) + 1):\n        \n        # Make a copy of the arrays.\n        local_tableau = tableau[:]\n        local_basis = basis[:]\n        \n        # Extract the row to edit (call it m).\n        m = local_tableau[row_idx]\n        \n        # Remove that row form the tableau, and create a new array with \n        # the rest of the rows.\n        rows = np.delete(local_tableau, row_idx, 0)\n        \n        # Obtain the intersection value for each basis element.\n        # Only for the basis rows (i.e. row_idx > 0). Row index of z is 0.\n        if row_idx > 0:\n            \n            # Obtain the value of the current row that must become one.\n            # This is the value at the intersection of the basis element\n            # rows and columns.\n            cur_intersection_value = m[local_basis[row_idx - 1]]\n        \n            # Delete the intersection value.\n            del local_basis[row_idx - 1]\n            \n        # If all basis column values in the current row are zero, and the \n        # column is not the objective function column (z)\n        if all(m[local_basis] == 0) and row_idx > 0:\n            \n            # Divide the row by the intersection value.\n            new_row = m/cur_intersection_value\n        else:\n            # Perform row operations to update the current row.\n            for row in rows:\n                e = [e for e, i in enumerate(m[local_basis]) if i != 0]\n                c = - m[local_basis][e]/row[local_basis][e]\n                new_row = m + c*row\n                \n                # Update until all basis column values are 0.\n                if all(new_row[local_basis] == 0):\n                    break\n        \n        # Append new row.\n        new_tableau.append(new_row)\n                \n    # Return the new matrix.\n    return np.array(new_tableau)\n        \n# Solve for the basis elements and update the A and b arrays.\nfor i, xb in enumerate(XB):\n    basis_element = A[i][xb]\n    if basis_element != 1:\n        A[i] = A[i]/basis_element  \n        b[0][i] /= basis_element\n\n# Dual simplex method to find an optimal solution.\ncount = 2\nz = np.array([list(z[0]) + [0]]) # Initialize solution to 0.\n\n# Print initial tableau.\nprint('\\n Tableau #1')\nfull_tableau = ct((z, ct((A, np.transpose(b)), axis = 1)))\nprint('Basis: ', XB)\nprint(full_tableau)\n\n# Solve.\ninfeasible = False\nwhile not all(b[0] > 0): \n    \n    # Identify the element that leaves the basis.\n    leaving = [i for i, y in enumerate(b[0] < 0) if y][0]\n    \n    # For the row that corresponds to the element that is leaving the \n    # basis, identify the elements that are negative.\n    col_idxs = [i for i, y in enumerate(A[leaving] < 0) if y]\n    negatives = A[leaving][col_idxs]\n    \n    # If there are no negatives in the row, the problem is infeasible.\n    # Break.\n    if len(negatives) == 0:\n        infeasible = True\n        print('Infeasible solution.')\n        break \n    \n    # Use the minimum ratio test to determine the element entering the basis.\n    d = abs(np.divide(z[0][col_idxs], negatives))   \n    entering = col_idxs[np.argmin(d)]\n    \n    # Update the basis.\n    XB[leaving] = entering \n    \n    # Update the tableau.\n    full_tableau = ct((z, ct((A, np.transpose(b)), axis = 1)))\n    full_tableau = update_tableau(full_tableau, XB)\n    \n    # Extract the new vectors and matrices from the tableau.\n    z = np.expand_dims(full_tableau[0], 0)\n    A = full_tableau[1:, :-1]\n    b = np.transpose(full_tableau[1:, -1:])\n    \n    # Print the new tableau.\n    print('\\n Tableau #', count)\n    print('Basis: ', XB)\n    print(full_tableau)\n    count += 1\n    \n# Print solutions.\nif not infeasible:\n    print('\\n Primal solution:')\n    for e, i in enumerate(b[0], 1):\n        print('X%d = %f' % (e, i))\n    print('z = ', -1*z[0][-1])\n        \n    print('\\n Dual solution:')\n    ct = 1\n    for e, i in enumerate(z[0][:-1], 0):\n        if e not in XB: \n            print('Y%d = %f' % (ct, z[0][e]*-1))\n            ct += 1\n    print('w = ', -1*z[0][-1])\n"
                },
                {
                    "name": "test3.py",
                    "type": "ADD",
                    "added": 75,
                    "deleted": 0,
                    "loc": 53,
                    "source": "import numpy as np\nfrom scipy.optimize import linprog\ntest = {'A': np.array([[ 1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  0.,  0.,  0.,  0.,  0.,\n         0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  1.,  0.,  0.,\n         1.,  0.,  0.,  0.,  0.,  1.,  0.,  0.,  0.,  1.,  1.],\n       [ 1.,  1.,  1.,  0.,  0.,  0.,  0.,  0.,  1.,  1.,  1.,  1.,  1.,\n         1.,  0.,  0.,  0.,  1.,  0.,  0.,  0.,  0.,  0.,  1.,  0.,  0.,\n         1.,  0.,  0.,  0.,  0.,  1.,  0.,  0.,  0.,  1.,  0.],\n       [ 0.,  0.,  1.,  0.,  0.,  0.,  0.,  0.,  1.,  1.,  0.,  0.,  0.,\n         0.,  1.,  1.,  1.,  1.,  1.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,\n         0.,  0.,  0.,  0.,  0.,  0.,  1.,  1.,  0.,  0.,  1.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  1.,  0.,  0.,  0.,\n         0.,  1.,  0.,  0.,  0.,  0.,  1.,  1.,  1.,  0.,  0.,  0.,  0.,\n         0.,  0.,  1.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  1.,  0.,  0.,  0.,  0.,  0.,  1.,  0.,  0.,  0.,\n         0.,  0.,  1.,  0.,  0.,  0.,  1.,  0.,  0.,  1.,  1.,  1.,  1.,\n         0.,  0.,  0.,  0.,  0.,  0.,  1.,  0.,  0.,  0.,  1.],\n       [ 0.,  0.,  0.,  1.,  1.,  1.,  1.,  0.,  0.,  0.,  1.,  1.,  1.,\n         1.,  0.,  0.,  1.,  1.,  1.,  0.,  1.,  1.,  1.,  1.,  0.,  1.,\n         1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  0.,  1.,  1.],\n       [ 1.,  0.,  1.,  0.,  0.,  0.,  1.,  0.,  0.,  0.,  0.,  1.,  1.,\n         0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  1.,  0.,\n         1.,  1.,  0.,  0.,  0.,  0.,  0.,  1.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  1.,  0.,  0.,  1.,  1.,  1.,  1.,  0.,  0.,  0.,\n         1.,  0.,  0.,  0.,  1.,  0.,  0.,  1.,  1.,  1.,  0.,  0.,  1.,\n         0.,  0.,  1.,  1.,  0.,  0.,  1.,  1.,  1.,  1.,  1.],\n       [ 0.,  1.,  0.,  1.,  1.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,\n         0.,  0.,  0.,  0.,  0.,  1.,  1.,  0.,  1.,  1.,  0.,  0.,  0.,\n         0.,  1.,  0.,  1.,  1.,  0.,  0.,  0.,  1.,  1.,  1.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,\n         0.,  1.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,\n         0.,  0.,  0.,  0.,  0.,  1.,  1.,  0.,  0.,  0.,  1.],\n       [-0., 1., -0., -0., -0., -0., -0., -0., -0., -0., -0., -0., -0.,\n        -0., -0., -0., -0., -0., -0., -0., -0., -0., -0., -0., -0., -0.,\n        -0., -0., -0., -0., -0., -0., -0., -0., -0., -0., -0.]]), \n        'b': np.array([5, 1, 3, 5, 5, 3, 3, 2, 1, 4, 1]), \n        'c': [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], \n        'Q0': 5}\nbounds = [(0, test['Q0']) for _ in range(len(test['c']))]\n# H\u00e0m chuy\u1ec3n b\u00e0i to\u00e1n v\u1ec1 d\u1ea1ng chu\u1ea9n\ndef convert_to_standard_form(c, A, b, Q0):\n    m, n = A.shape\n\n    # Th\u00eam bi\u1ebfn gi\u1ea3 v\u00e0 bi\u1ebfn d\u01b0\n    A_standard = np.hstack((A, np.eye(m)))\n    c_standard = np.concatenate((c, np.zeros(m)))\n\n    # Chuy\u1ec3n r\u00e0ng bu\u1ed9c b\u1ea5t ph\u01b0\u01a1ng tr\u00ecnh th\u00e0nh ph\u01b0\u01a1ng tr\u00ecnh\n    A_eq = np.hstack((A_standard, np.zeros((m, m))))\n    b_eq = b\n\n    # Chuy\u1ec3n r\u00e0ng bu\u1ed9c x_i <= Q0 th\u00e0nh bi\u1ec3u di\u1ec5n t\u00e1ch bi\u1ebfn\n    A_ineq = np.hstack((np.eye(m), np.zeros((m, m))))\n    b_ineq = Q0 * np.ones(m)\n\n    # Bi\u1ebfn d\u01b0 v\u00e0 bi\u1ebfn gi\u1ea3 \u0111\u1ec1u ph\u1ea3i l\u00e0 kh\u00f4ng \u00e2m\n    bounds = [(0, None) for _ in range(n)] + [(None, None) for _ in range(m)] + [(0, None) for _ in range(m)]\n\n    return c_standard, A_eq, b_eq, A_ineq, b_ineq, bounds\n\n# Chuy\u1ec3n b\u00e0i to\u00e1n v\u1ec1 d\u1ea1ng chu\u1ea9n\nc_standard, A_eq, b_eq, A_ineq, b_ineq, bounds = convert_to_standard_form(test['c'], test['A'], test['b'], test['Q0'])\n\n# Gi\u1ea3i b\u00e0i to\u00e1n t\u1ed1i \u01b0u h\u00f3a tuy\u1ebfn t\u00ednh b\u1eb1ng linprog\nresult = linprog(c_standard, A_eq=A_eq, b_eq=b_eq, A_ub=A_ineq, b_ub=b_ineq, bounds=bounds, method='highs')\n\n# Hi\u1ec3n th\u1ecb k\u1ebft qu\u1ea3\nprint(\"Optimal values of x:\", result.x[:len(c)])\nprint(\"Optimal objective value:\", result.fun)\n\n\n\n\n\n\n"
                }
            ],
            "parents": [
                "1c6d0615ce5c56c4a73cfa15ea6cbf3f920d6ef6"
            ]
        },
        {
            "sha": "c28fb72f2474bbc8e39fef9223270892cef7a202",
            "committer": "Grizzlazy",
            "msg": "Update",
            "date": "01/07/24T16:46:56",
            "modified_files": [
                {
                    "name": "main.py",
                    "type": "MODIFY",
                    "added": 0,
                    "deleted": 1,
                    "loc": 85,
                    "source": "import data\nimport simplex_method\nimport queue\nimport math\nimport numpy as np\nimport copy\nfrom scipy.optimize import linprog\n\nfile_name_csv = \"Data/N=10_W=30_H=40_normal_0.csv\"\n\nT = [] #Target\nQ = [] #Demand\nI = [] #Target isolated\nP = [] #Good position for placing sensors\nx = [] #Number of sensors in P\na = [] #Sensor j cover by position P_i\nT, Q = data.read_data(file_name_csv)\n\nP, a = data.find_positions(T)\n\nc = [1]*len(P)\nQ_0 = max(Q) #Highest demand\nepsilon = (-1)*0.000001\n\ndef isInteger(x):\n    for i in range (len(P)):\n        if not float(x[i]).is_integer():\n            index = i\n            return False, index\n    return True, None\n\ndef create_subproblem(A, b, c, solution):\n    # Create subproblem with rounded down constraints\n    index = isInteger(solution)[1]\n    floor_constraint = np.zeros(len(P))\n    floor_constraint[index] = 1\n\n    subproblem_floor = {\n        'A': np.vstack([A, floor_constraint]),\n        'b': np.concatenate([b, [int(solution[index]) + 1]]),\n        'c': c\n    }\n\n    # Create subproblem with rounded up constraints\n    ceil_constraint = -floor_constraint\n    subproblem_ceil = {\n        'A': np.vstack([A, ceil_constraint]),\n        'b': np.concatenate([b, [-int(solution[index])]]),\n        'c': c\n    }\n\n    return subproblem_floor, subproblem_ceil\n\ndef simplex_method1(a, Q, c):\n    A = -1 * np.array(a)  # Assuming 'a' is a matrix of coefficients\n\n    # Inequality constraints RHS\n    b = -1 * np.array(Q)  # Assuming 'q' is a vector of constants\n    Q0 = max(Q)\n    # Bounds for variables\n    x0_bounds = (0, Q0)\n    bounds = [x0_bounds] * len(c)\n\n    # Solve the linear programming problem\n    result = linprog(c, A_ub=A, b_ub=b, bounds=bounds, method='highs')\n\n    if result.success:\n        optimal_solution = [round(x, 6) for x in result.x]\n        optimal_value = round(result.fun, 6)\n    else:\n        optimal_solution = None\n        optimal_value = None\n\n    return result.success, optimal_solution, optimal_value\n\ndef branch_and_bound(A, b, c):\n    q = queue.Queue()\n    iteration = 1e6\n    best_value = 1e6\n    best_solution = []\n    initial_problem = {'A': A, 'b': b, 'c': c}\n    q.put(initial_problem)\n    while not q.empty():\n        current_problem = q.get()\n        flag, current_solution, current_value = simplex_method1(current_problem['A'], current_problem['b'], current_problem['c'])\n        print(flag, current_solution)\n        if not flag: continue\n        if isInteger(current_solution)[0]:\n            if current_value - best_value < epsilon:\n                best_solution = copy.deepcopy(current_solution)\n                best_value = current_value\n        else:\n            if current_value - best_value < epsilon:\n                subproblem_floor, subproblem_ceil = create_subproblem(current_problem['A'], current_problem['b'], current_problem['c'], current_solution)\n                q.put(subproblem_floor)\n                q.put(subproblem_ceil)\n        #print('---------',iteration, '-----------')\n        print(current_value)\n        print(current_solution)\n        #iteration -=1\n    \n    if best_solution == []:\n        return False, None, None\n    return True, best_solution, best_value\n\nflag, x,  optimal_solution = branch_and_bound(a, Q, c)\n\nprint(flag)\nprint(x)\nprint(optimal_solution)"
                }
            ],
            "parents": [
                "519530794c367981a6c91978243a7658c9482567"
            ]
        },
        {
            "sha": "3b8aeda734a090916c609cdd75f0e428641514dd",
            "committer": "Grizzlazy",
            "msg": "Update",
            "date": "01/07/24T17:20:39",
            "modified_files": [
                {
                    "name": "data.py",
                    "type": "MODIFY",
                    "added": 16,
                    "deleted": 9,
                    "loc": 62,
                    "source": "import math\n\nfile_name_csv = \"Data/N=10_W=10_H=8_normal_0.csv\"\n\nN = 10  # number of targets\nW = 30  # width\nH = 40  # height\nR = 3  # radius of sensor\ndeltaR = 0.02\ndef read_data(path):\n    coordinates = []\n    demand = []\n    with open(path, 'r') as f:\n        # Read the header line\n        header = f.readline()\n\n        for _ in range(N):\n            line = f.readline().strip().split(',')\n            x, y, q = map(float, line)\n            coordinates.append((x, y))\n            demand.append(int(q))\n\n    return coordinates, demand\n\ndef get_distances(X, Y):\n    return math.sqrt((X[0]-Y[0])*(X[0]-Y[0])+(X[0]-Y[0])*(X[0]-Y[0]))\n\ndef find_positions(coordinates):\n    unique_positions = set()\n\n    check = [0]*N\n    for i in range(len(coordinates)-1):\n        for j in range(i+1, len(coordinates)):\n            if get_distances(coordinates[i], coordinates[j]) <= 2*R + deltaR:\n                check[i]+=1\n                check[j]+=1\n                \n                midpoint = ((coordinates[i][0] + coordinates[j][0])/2, (coordinates[i][1] + coordinates[j][1])/2)\n                angle = math.atan2(coordinates[j][1] - coordinates[i][1], coordinates[j][0] - coordinates[i][0])\n\n                x_p1 = round(midpoint[0] + R * math.cos(angle + math.pi/2), 15)\n                y_p1 = round(midpoint[1] + R * math.sin(angle + math.pi/2), 15)\n\n                x_p2 = round(midpoint[0] - R * math.cos(angle + math.pi/2), 15)\n                y_p2 = round(midpoint[1] - R * math.sin(angle + math.pi/2), 15)\n\n                if 0 <= x_p1 <= W and 0 <= y_p1 <= H:\n                    unique_positions.add((x_p1, y_p1))\n                    print((x_p1, y_p1), (i, j))\n                if 0 <= x_p2 <= W and 0 <= y_p2 <= H:\n                    unique_positions.add((x_p2, y_p2))\n                    print((x_p2, y_p2), (i, j))\n\n    for i in range(len(coordinates)):\n        if check[i] == 0: \n            unique_positions.add((coordinates[i][0], coordinates[i][1]))\n            print((coordinates[i][0], coordinates[i][1]), i)\n    \n    targetted = []\n    for i in range(len(list(unique_positions))):\n        temp = []\n        targetted.append(temp)\n\n    for i in range(len(list(unique_positions))):\n        for j in range(len(coordinates)):\n            if j == 0: print(get_distances(list(unique_positions)[i], coordinates[j]), list(unique_positions)[i])\n            if get_distances(list(unique_positions)[i], coordinates[j]) <= R + deltaR:\n                #print(i, j)\n                targetted[i].append(j)\n    \n    a = []\n    for j in range(len(coordinates)):\n        temp = [0]*len(list(unique_positions))\n        a.append(temp)\n\n    for j in range(len(coordinates)):\n        for i in range(len(list(unique_positions))):\n            if j in targetted[i]:\n                a[j][i] = 1\n    \n    return list(unique_positions), a\n\n"
                },
                {
                    "name": "main.py",
                    "type": "MODIFY",
                    "added": 3,
                    "deleted": 1,
                    "loc": 88,
                    "source": "import data\nimport simplex_method\nimport queue\nimport math\nimport numpy as np\nimport copy\nfrom scipy.optimize import linprog\n\nfile_name_csv = \"Data/N=10_W=30_H=40_normal_0.csv\"\n\nT = [] #Target\nQ = [] #Demand\nI = [] #Target isolated\nP = [] #Good position for placing sensors\nx = [] #Number of sensors in P\na = [] #Sensor j cover by position P_i\nT, Q = data.read_data(file_name_csv)\n\nP, a = data.find_positions(T)\nprint(P)\na = np.array(a)\nprint(a)\nc = [1]*len(P)\nQ_0 = max(Q) #Highest demand\nepsilon = (-1)*0.000001\n\ndef isInteger(x):\n    for i in range (len(P)):\n        if not float(x[i]).is_integer():\n            index = i\n            return False, index\n    return True, None\n\ndef create_subproblem(A, b, c, solution):\n    # Create subproblem with rounded down constraints\n    index = isInteger(solution)[1]\n    floor_constraint = np.zeros(len(P))\n    floor_constraint[index] = 1\n\n    subproblem_floor = {\n        'A': np.vstack([A, floor_constraint]),\n        'b': np.concatenate([b, [int(solution[index]) + 1]]),\n        'c': c\n    }\n\n    # Create subproblem with rounded up constraints\n    ceil_constraint = -floor_constraint\n    subproblem_ceil = {\n        'A': np.vstack([A, ceil_constraint]),\n        'b': np.concatenate([b, [-int(solution[index])]]),\n        'c': c\n    }\n\n    return subproblem_floor, subproblem_ceil\n\ndef simplex_method1(a, Q, c):\n    A = -1 * np.array(a)  # Assuming 'a' is a matrix of coefficients\n\n    # Inequality constraints RHS\n    b = -1 * np.array(Q)  # Assuming 'q' is a vector of constants\n    Q0 = max(Q)\n    # Bounds for variables\n    x0_bounds = (0, Q0)\n    bounds = [x0_bounds] * len(c)\n\n    # Solve the linear programming problem\n    result = linprog(c, A_ub=A, b_ub=b, bounds=bounds, method='highs')\n\n    if result.success:\n        optimal_solution = [round(x, 6) for x in result.x]\n        optimal_value = round(result.fun, 6)\n    else:\n        optimal_solution = None\n        optimal_value = None\n\n    return result.success, optimal_solution, optimal_value\n\ndef branch_and_bound(A, b, c):\n    q = queue.Queue()\n    iteration = 1e6\n    best_value = 1e6\n    best_solution = []\n    initial_problem = {'A': A, 'b': b, 'c': c}\n    q.put(initial_problem)\n    while not q.empty():\n        current_problem = q.get()\n        flag, current_solution, current_value = simplex_method1(current_problem['A'], current_problem['b'], current_problem['c'])\n        print(flag, current_solution)\n        if not flag: continue\n        if isInteger(current_solution)[0]:\n            if current_value - best_value < epsilon:\n                best_solution = copy.deepcopy(current_solution)\n                best_value = current_value\n        else:\n            if current_value - best_value < epsilon:\n                subproblem_floor, subproblem_ceil = create_subproblem(current_problem['A'], current_problem['b'], current_problem['c'], current_solution)\n                q.put(subproblem_floor)\n                q.put(subproblem_ceil)\n        #print('---------',iteration, '-----------')\n        print(current_value)\n        print(current_solution)\n        #iteration -=1\n    \n    if best_solution == []:\n        return False, None, None\n    return True, best_solution, best_value\n\nflag, x,  optimal_solution = branch_and_bound(a, Q, c)\n\nprint(flag)\nprint(x)\nprint(optimal_solution)"
                }
            ],
            "parents": [
                "c28fb72f2474bbc8e39fef9223270892cef7a202"
            ]
        },
        {
            "sha": "049d18ee1177a5631c0fd3bc018e40c446902eaf",
            "committer": "Grizzlazy",
            "msg": "Update",
            "date": "01/07/24T21:18:02",
            "modified_files": [
                {
                    "name": "data.py",
                    "type": "MODIFY",
                    "added": 30,
                    "deleted": 16,
                    "loc": 73,
                    "source": "import math\n\nN = 20  # number of targets\nW = 30  # width\nH = 40  # height\nR = 5  # radius of sensor\ndeltaR = 0.001\n\ndef read_data(path):\n    coordinates = []\n    demand = []\n    with open(path, 'r') as f:\n        # Read the header line\n        header = f.readline()\n\n        for _ in range(N):\n            line = f.readline().strip().split(',')\n            x, y, q = map(float, line)\n            coordinates.append((x, y))\n            demand.append(int(q))\n\n    return coordinates, demand\n\ndef get_distances(X, Y):\n    return math.sqrt((X[0]-Y[0])*(X[0]-Y[0])+(X[1]-Y[1])*(X[1]-Y[1]))\n\ndef find_positions(coordinates):\n    unique_positions = set()\n    check = [0]*N\n    for i in range(len(coordinates)-1):\n        for j in range(i+1, len(coordinates)):\n            if get_distances(coordinates[i], coordinates[j]) <= 2*R + deltaR:\n                check[i]+=1\n                check[j]+=1\n                \n                midpoint = ((coordinates[i][0] + coordinates[j][0])/2, (coordinates[i][1] + coordinates[j][1])/2)\n                '''angle = math.atan2(coordinates[j][1] - coordinates[i][1], coordinates[j][0] - coordinates[i][0])\n\n                x_p1 = midpoint[0] + R * math.cos(angle + math.pi/2)\n                y_p1 = midpoint[1] + R * math.sin(angle + math.pi/2)\n\n                x_p2 = midpoint[0] - R * math.cos(angle + math.pi/2)\n                y_p2 = midpoint[1] - R * math.sin(angle + math.pi/2)'''\n                u = midpoint[0]\n                v = midpoint[1]\n                b = coordinates[j][1] - coordinates[i][1]\n                a = coordinates[j][0] - coordinates[i][0]\n                if a*b < 0:\n                    x_p1 = u + math.sqrt((R*R-(a*a+b*b)/4)*b*b/(a*a+b*b))\n                    y_p1 = v + math.sqrt((R*R-(a*a+b*b)/4)*a*a/(a*a+b*b))\n\n                    x_p2 = u - math.sqrt((R*R-(a*a+b*b)/4)*b*b/(a*a+b*b))\n                    y_p2 = v - math.sqrt((R*R-(a*a+b*b)/4)*a*a/(a*a+b*b))\n                else:\n                    x_p1 = u - math.sqrt((R*R-(a*a+b*b)/4)*b*b/(a*a+b*b))\n                    y_p1 = v + math.sqrt((R*R-(a*a+b*b)/4)*a*a/(a*a+b*b))\n\n                    x_p2 = u + math.sqrt((R*R-(a*a+b*b)/4)*b*b/(a*a+b*b))\n                    y_p2 = v - math.sqrt((R*R-(a*a+b*b)/4)*a*a/(a*a+b*b))\n\n                if 0 <= x_p1 <= W and 0 <= y_p1 <= H:\n                    unique_positions.add((x_p1, y_p1))\n                    #print((x_p1, y_p1), (i, j), get_distances((x_p1, y_p1), coordinates[i]))\n                if 0 <= x_p2 <= W and 0 <= y_p2 <= H:\n                    unique_positions.add((x_p2, y_p2))\n                    #print((x_p2, y_p2), (i, j), get_distances((x_p2, y_p2), coordinates[i]))\n\n    for i in range(len(coordinates)):\n        if check[i] == 0: \n            unique_positions.add((coordinates[i][0], coordinates[i][1]))\n            #print((coordinates[i][0], coordinates[i][1]), i)\n    \n    targetted = []\n    for i in range(len(list(unique_positions))):\n        temp = []\n        targetted.append(temp)\n\n    for i in range(len(list(unique_positions))):\n        for j in range(len(coordinates)):\n            #if j == 0: print(get_distances(list(unique_positions)[i], coordinates[j]), list(unique_positions)[i])\n            if get_distances(list(unique_positions)[i], coordinates[j]) <= R + deltaR:\n                #print(i, j)\n                targetted[i].append(j)\n    \n    a = []\n    for j in range(len(coordinates)):\n        temp = [0]*len(list(unique_positions))\n        a.append(temp)\n\n    for j in range(len(coordinates)):\n        for i in range(len(list(unique_positions))):\n            if j in targetted[i]:\n                a[j][i] = 1\n    \n    return list(unique_positions), a\n\n"
                },
                {
                    "name": "main.py",
                    "type": "MODIFY",
                    "added": 3,
                    "deleted": 10,
                    "loc": 84,
                    "source": "import data\nimport simplex_method\nimport queue\nimport math\nimport numpy as np\nimport copy\nfrom scipy.optimize import linprog\n\nfile_name_csv = \"Data/N=20_W=30_H=40_normal_0.csv\"\n\nT = [] #Target\nQ = [] #Demand\nI = [] #Target isolated\nP = [] #Good position for placing sensors\nx = [] #Number of sensors in P\na = [] #Sensor j cover by position P_i\nT, Q = data.read_data(file_name_csv)\n\nP, a = data.find_positions(T)\nc = [1]*len(P)\nepsilon = (-1)*0.000001\n\ndef isInteger(x):\n    for i in range (len(P)):\n        if not float(x[i]).is_integer():\n            index = i\n            return False, index\n    return True, None\n\ndef create_subproblem(A, b, c, solution):\n    index = isInteger(solution)[1]\n    floor_constraint = np.zeros(len(P))\n    floor_constraint[index] = 1\n\n    subproblem_floor = {\n        'A': np.vstack([A, floor_constraint]),\n        'b': np.concatenate([b, [int(solution[index]) + 1]]),\n        'c': c\n    }\n\n    ceil_constraint = -floor_constraint\n    subproblem_ceil = {\n        'A': np.vstack([A, ceil_constraint]),\n        'b': np.concatenate([b, [-int(solution[index])]]),\n        'c': c\n    }\n\n    return subproblem_floor, subproblem_ceil\n\ndef simplex_method1(a, Q, c):\n    A = -1 * np.array(a) \n\n    b = -1 * np.array(Q) \n    Q0 = max(Q)\n    # Bounds for variables\n    x0_bounds = (0, Q0)\n    bounds = [x0_bounds] * len(c)\n\n    # Solve the linear programming problem\n    result = linprog(c, A_ub=A, b_ub=b, bounds=bounds, method='highs')\n\n    if result.success:\n        optimal_solution = [round(x, 6) for x in result.x]\n        optimal_value = round(result.fun, 6)\n    else:\n        optimal_solution = None\n        optimal_value = None\n\n    return result.success, optimal_solution, optimal_value\n\ndef branch_and_bound(A, b, c):\n    q = queue.Queue()\n    iteration = 1e6\n    best_value = 1e6\n    best_solution = []\n    initial_problem = {'A': A, 'b': b, 'c': c}\n    q.put(initial_problem)\n    while not q.empty():\n        current_problem = q.get()\n        flag, current_solution, current_value = simplex_method1(current_problem['A'], current_problem['b'], current_problem['c'])\n        print(flag, current_solution)\n        if not flag: continue\n        if isInteger(current_solution)[0]:\n            if current_value - best_value < epsilon:\n                best_solution = copy.deepcopy(current_solution)\n                best_value = current_value\n        else:\n            if current_value - best_value < epsilon:\n                subproblem_floor, subproblem_ceil = create_subproblem(current_problem['A'], current_problem['b'], current_problem['c'], current_solution)\n                q.put(subproblem_floor)\n                q.put(subproblem_ceil)\n        #print('---------',iteration, '-----------')\n        print(current_value)\n        print(current_solution)\n        #iteration -=1\n    \n    if best_solution == []:\n        return False, None, None\n    return True, best_solution, best_value\n\nflag, x,  optimal_solution = branch_and_bound(a, Q, c)\n\nprint(flag)\nprint(x)\nprint(optimal_solution)"
                }
            ],
            "parents": [
                "3b8aeda734a090916c609cdd75f0e428641514dd"
            ]
        },
        {
            "sha": "959096e4fdde6eed9cc28628ce78e7d9f81ca0e3",
            "committer": "Grizzlazy",
            "msg": "Update part n",
            "date": "01/07/24T21:25:34",
            "modified_files": [
                {
                    "name": "main.py",
                    "type": "MODIFY",
                    "added": 17,
                    "deleted": 6,
                    "loc": 89,
                    "source": "import data\nimport simplex_method\nimport queue\nimport math\nimport numpy as np\nimport copy\nfrom scipy.optimize import linprog\n\nfile_name_csv = \"Data/N=20_W=30_H=40_normal_0.csv\"\n\nT = [] #Target\nQ = [] #Demand\nI = [] #Target isolated\nP = [] #Good position for placing sensors\nx = [] #Number of sensors in P\na = [] #Sensor j cover by position P_i\nT, Q = data.read_data(file_name_csv)\n\nP, a = data.find_positions(T)\nc = [1]*len(P)\nepsilon = (-1)*0.000001\n\ndef isInteger(x):\n    for i in range (len(P)):\n        if not float(x[i]).is_integer():\n            index = i\n            return False, index\n    return True, None\n\ndef create_subproblem(A, b, c, solution):\n    index = isInteger(solution)[1]\n    floor_constraint = np.zeros(len(P))\n    floor_constraint[index] = 1\n\n    subproblem_floor = {\n        'A': np.vstack([A, floor_constraint]),\n        'b': np.concatenate([b, [int(solution[index]) + 1]]),\n        'c': c\n    }\n\n    ceil_constraint = -floor_constraint\n    subproblem_ceil = {\n        'A': np.vstack([A, ceil_constraint]),\n        'b': np.concatenate([b, [-int(solution[index])]]),\n        'c': c\n    }\n\n    return subproblem_floor, subproblem_ceil\n\ndef simplex_method1(a, Q, c):\n    A = -1 * np.array(a) \n\n    b = -1 * np.array(Q) \n    Q0 = max(Q)\n    # Bounds for variables\n    x0_bounds = (0, Q0)\n    bounds = [x0_bounds] * len(c)\n\n    # Solve the linear programming problem\n    result = linprog(c, A_ub=A, b_ub=b, bounds=bounds, method='highs')\n\n    if result.success:\n        optimal_solution = [round(x, 6) for x in result.x]\n        optimal_value = round(result.fun, 6)\n    else:\n        optimal_solution = None\n        optimal_value = None\n\n    return result.success, optimal_solution, optimal_value\n\ndef branch_and_bound(A, b, c):\n    q = queue.Queue()\n    iteration = 1e6\n    best_value = 1e6\n    best_solution = []\n    initial_problem = {'A': A, 'b': b, 'c': c}\n    q.put(initial_problem)\n    while not q.empty():\n        current_problem = q.get()\n        flag, current_solution, current_value = simplex_method1(current_problem['A'], current_problem['b'], current_problem['c'])\n        # print(flag, current_solution)\n        if not flag: continue\n        if isInteger(current_solution)[0]:\n            if current_value - best_value < epsilon:\n                best_solution = copy.deepcopy(current_solution)\n                best_value = current_value\n        else:\n            if current_value - best_value < epsilon:\n                subproblem_floor, subproblem_ceil = create_subproblem(current_problem['A'], current_problem['b'], current_problem['c'], current_solution)\n                q.put(subproblem_floor)\n                q.put(subproblem_ceil)\n        #print('---------',iteration, '-----------')\n        # print(current_value)\n        # print(current_solution)\n        #iteration -=1\n    \n    if best_solution == []:\n        return False, None, None\n    return True, best_solution, best_value\n\nflag, x,  optimal_solution = branch_and_bound(a, Q, c)\n\ndef convert_output(x):\n    output = []\n    for i in range(len(P)):\n        if x[i] != 0:\n            output.append((P[i], x[i]))\n    \n    return output\n\noutput = convert_output(x)\nif flag:\n    for i in range(len(output)):\n        print(\"Number of sensors in P\",output[i][0],\" is \", int(output[i][1]))\n    \n    print(\"Total sensors: \", int(optimal_solution))\n"
                }
            ],
            "parents": [
                "049d18ee1177a5631c0fd3bc018e40c446902eaf"
            ]
        },
        {
            "sha": "ea0548da1880a08d37baf1a188dc2eeca63aac8f",
            "committer": "Grizzlazy",
            "msg": "Update final final",
            "date": "01/07/24T22:09:46",
            "modified_files": [
                {
                    "name": "data.py",
                    "type": "MODIFY",
                    "added": 1,
                    "deleted": 1,
                    "loc": 73,
                    "source": "import math\n\nN = 20  # number of targets\nW = 30  # width\nH = 40  # height\nR = 5  # radius of sensor\ndeltaR = 0.1\n\ndef read_data(path):\n    coordinates = []\n    demand = []\n    with open(path, 'r') as f:\n        # Read the header line\n        header = f.readline()\n\n        for _ in range(N):\n            line = f.readline().strip().split(',')\n            x, y, q = map(float, line)\n            coordinates.append((x, y))\n            demand.append(int(q))\n\n    return coordinates, demand\n\ndef get_distances(X, Y):\n    return math.sqrt((X[0]-Y[0])*(X[0]-Y[0])+(X[1]-Y[1])*(X[1]-Y[1]))\n\ndef find_positions(coordinates):\n    unique_positions = set()\n    check = [0]*N\n    for i in range(len(coordinates)-1):\n        for j in range(i+1, len(coordinates)):\n            if get_distances(coordinates[i], coordinates[j]) <= 2*R + deltaR:\n                check[i]+=1\n                check[j]+=1\n                \n                midpoint = ((coordinates[i][0] + coordinates[j][0])/2, (coordinates[i][1] + coordinates[j][1])/2)\n                '''angle = math.atan2(coordinates[j][1] - coordinates[i][1], coordinates[j][0] - coordinates[i][0])\n\n                x_p1 = midpoint[0] + R * math.cos(angle + math.pi/2)\n                y_p1 = midpoint[1] + R * math.sin(angle + math.pi/2)\n\n                x_p2 = midpoint[0] - R * math.cos(angle + math.pi/2)\n                y_p2 = midpoint[1] - R * math.sin(angle + math.pi/2)'''\n                u = midpoint[0]\n                v = midpoint[1]\n                b = coordinates[j][1] - coordinates[i][1]\n                a = coordinates[j][0] - coordinates[i][0]\n                if a*b < 0:\n                    x_p1 = u + math.sqrt((R*R-(a*a+b*b)/4)*b*b/(a*a+b*b))\n                    y_p1 = v + math.sqrt((R*R-(a*a+b*b)/4)*a*a/(a*a+b*b))\n\n                    x_p2 = u - math.sqrt((R*R-(a*a+b*b)/4)*b*b/(a*a+b*b))\n                    y_p2 = v - math.sqrt((R*R-(a*a+b*b)/4)*a*a/(a*a+b*b))\n                else:\n                    x_p1 = u - math.sqrt((R*R-(a*a+b*b)/4)*b*b/(a*a+b*b))\n                    y_p1 = v + math.sqrt((R*R-(a*a+b*b)/4)*a*a/(a*a+b*b))\n\n                    x_p2 = u + math.sqrt((R*R-(a*a+b*b)/4)*b*b/(a*a+b*b))\n                    y_p2 = v - math.sqrt((R*R-(a*a+b*b)/4)*a*a/(a*a+b*b))\n\n                if 0 <= x_p1 <= W and 0 <= y_p1 <= H:\n                    unique_positions.add((x_p1, y_p1))\n                    #print((x_p1, y_p1), (i, j), get_distances((x_p1, y_p1), coordinates[i]))\n                if 0 <= x_p2 <= W and 0 <= y_p2 <= H:\n                    unique_positions.add((x_p2, y_p2))\n                    #print((x_p2, y_p2), (i, j), get_distances((x_p2, y_p2), coordinates[i]))\n\n    for i in range(len(coordinates)):\n        if check[i] == 0: \n            unique_positions.add((coordinates[i][0], coordinates[i][1]))\n            #print((coordinates[i][0], coordinates[i][1]), i)\n    \n    targetted = []\n    for i in range(len(list(unique_positions))):\n        temp = []\n        targetted.append(temp)\n\n    for i in range(len(list(unique_positions))):\n        for j in range(len(coordinates)):\n            #if j == 0: print(get_distances(list(unique_positions)[i], coordinates[j]), list(unique_positions)[i])\n            if get_distances(list(unique_positions)[i], coordinates[j]) <= R + deltaR:\n                #print(i, j)\n                targetted[i].append(j)\n    \n    a = []\n    for j in range(len(coordinates)):\n        temp = [0]*len(list(unique_positions))\n        a.append(temp)\n\n    for j in range(len(coordinates)):\n        for i in range(len(list(unique_positions))):\n            if j in targetted[i]:\n                a[j][i] = 1\n    \n    return list(unique_positions), a\n\n"
                },
                {
                    "name": "main.py",
                    "type": "MODIFY",
                    "added": 30,
                    "deleted": 1,
                    "loc": 112,
                    "source": "import data\nimport simplex_method\nimport queue\nimport math\nimport numpy as np\nimport copy\nfrom scipy.optimize import linprog\nimport matplotlib.pyplot as plt\nfile_name_csv = \"Data/N=20_W=30_H=40_normal_0.csv\"\n\nT = [] #Target\nQ = [] #Demand\nI = [] #Target isolated\nP = [] #Good position for placing sensors\nx = [] #Number of sensors in P\na = [] #Sensor j cover by position P_i\nT, Q = data.read_data(file_name_csv)\n\nP, a = data.find_positions(T)\nc = [1]*len(P)\nepsilon = (-1)*0.000001\n\ndef isInteger(x):\n    for i in range (len(P)):\n        if not float(x[i]).is_integer():\n            index = i\n            return False, index\n    return True, None\n\ndef create_subproblem(A, b, c, solution):\n    index = isInteger(solution)[1]\n    floor_constraint = np.zeros(len(P))\n    floor_constraint[index] = 1\n\n    subproblem_floor = {\n        'A': np.vstack([A, floor_constraint]),\n        'b': np.concatenate([b, [int(solution[index]) + 1]]),\n        'c': c\n    }\n\n    ceil_constraint = -floor_constraint\n    subproblem_ceil = {\n        'A': np.vstack([A, ceil_constraint]),\n        'b': np.concatenate([b, [-int(solution[index])]]),\n        'c': c\n    }\n\n    return subproblem_floor, subproblem_ceil\n\ndef simplex_method1(a, Q, c):\n    A = -1 * np.array(a) \n\n    b = -1 * np.array(Q) \n    Q0 = max(Q)\n    # Bounds for variables\n    x0_bounds = (0, Q0)\n    bounds = [x0_bounds] * len(c)\n\n    # Solve the linear programming problem\n    result = linprog(c, A_ub=A, b_ub=b, bounds=bounds, method='highs')\n\n    if result.success:\n        optimal_solution = [round(x, 6) for x in result.x]\n        optimal_value = round(result.fun, 6)\n    else:\n        optimal_solution = None\n        optimal_value = None\n\n    return result.success, optimal_solution, optimal_value\n\ndef branch_and_bound(A, b, c):\n    q = queue.Queue()\n    iteration = 1e6\n    best_value = 1e6\n    best_solution = []\n    initial_problem = {'A': A, 'b': b, 'c': c}\n    q.put(initial_problem)\n    while not q.empty():\n        current_problem = q.get()\n        flag, current_solution, current_value = simplex_method1(current_problem['A'], current_problem['b'], current_problem['c'])\n        # print(flag, current_solution)\n        if not flag: continue\n        if isInteger(current_solution)[0]:\n            if current_value - best_value < epsilon:\n                best_solution = copy.deepcopy(current_solution)\n                best_value = current_value\n        else:\n            if current_value - best_value < epsilon:\n                subproblem_floor, subproblem_ceil = create_subproblem(current_problem['A'], current_problem['b'], current_problem['c'], current_solution)\n                q.put(subproblem_floor)\n                q.put(subproblem_ceil)\n        #print('---------',iteration, '-----------')\n        # print(current_value)\n        # print(current_solution)\n        #iteration -=1\n    \n    if best_solution == []:\n        return False, None, None\n    return True, best_solution, best_value\n\nflag, x,  optimal_solution = branch_and_bound(a, Q, c)\n\ndef convert_output(x):\n    output = []\n    for i in range(len(P)):\n        if x[i] != 0:\n            output.append((P[i], x[i]))\n    \n    return output\n\noutput = convert_output(x)\nif flag:\n    for i in range(len(output)):\n        print(\"Number of sensors in P\",output[i][0],\" is \", int(output[i][1]))\n    \n    print(\"Total sensors: \", int(optimal_solution))\n# Create a new figure with specified size\nplt.figure(figsize=(data.W, data.H))\n\n# Set x-axis and y-axis limits based on W and H\n\n\nfor i in range(len(output)):\n    center = np.array(output[i][0])\n    theta = np.linspace(0, 2*np.pi, 100)\n    x = (data.R+data.deltaR) * np.cos(theta) + center[0]\n    y = (data.R+data.deltaR) * np.sin(theta) + center[1]   \n    plt.plot(x, y, color = 'blue')\n    if i == 0:\n        plt.scatter(center[0], center[1], color='red', label = 'Sensors')\n    else:\n        plt.scatter(center[0], center[1], color='red')\n\nfor i in range(len(T)):\n    if i == 0:\n        plt.scatter(T[i][0], T[i][1], color='green', marker='*', label = 'Targets')\n    else:\n        plt.scatter(T[i][0], T[i][1], color='green', marker='*')\n\nplt.axis([0, data.W, 0, data.H])\nplt.gca().set_aspect('equal', adjustable='box')\nplt.legend()\nplt.xlabel('X-axis')\nplt.ylabel('Y-axis')\nplt.show()"
                }
            ],
            "parents": [
                "959096e4fdde6eed9cc28628ce78e7d9f81ca0e3"
            ]
        },
        {
            "sha": "748fed39c35e28a6246abf7c323a769d71bf1c6d",
            "committer": "Grizzlazy",
            "msg": "Update",
            "date": "01/07/24T22:17:14",
            "modified_files": [
                {
                    "name": "data.py",
                    "type": "MODIFY",
                    "added": 1,
                    "deleted": 0,
                    "loc": 73,
                    "source": "import math\n\nN = 20  # number of targets\nW = 30  # width\nH = 40  # height\nR = 5  # radius of sensor\ndeltaR = 0.1\n\ndef read_data(path):\n    coordinates = []\n    demand = []\n    with open(path, 'r') as f:\n        # Read the header line\n        header = f.readline()\n\n        for _ in range(N):\n            line = f.readline().strip().split(',')\n            x, y, q = map(float, line)\n            coordinates.append((x, y))\n            demand.append(int(q))\n\n    return coordinates, demand\n\ndef get_distances(X, Y):\n    return math.sqrt((X[0]-Y[0])*(X[0]-Y[0])+(X[1]-Y[1])*(X[1]-Y[1]))\n\ndef find_positions(coordinates):\n    unique_positions = set()\n    check = [0]*N\n    for i in range(len(coordinates)-1):\n        for j in range(i+1, len(coordinates)):\n            if get_distances(coordinates[i], coordinates[j]) <= 2*R + deltaR:\n                check[i]+=1\n                check[j]+=1\n                \n                midpoint = ((coordinates[i][0] + coordinates[j][0])/2, (coordinates[i][1] + coordinates[j][1])/2)\n                '''angle = math.atan2(coordinates[j][1] - coordinates[i][1], coordinates[j][0] - coordinates[i][0])\n\n                x_p1 = midpoint[0] + R * math.cos(angle + math.pi/2)\n                y_p1 = midpoint[1] + R * math.sin(angle + math.pi/2)\n\n                x_p2 = midpoint[0] - R * math.cos(angle + math.pi/2)\n                y_p2 = midpoint[1] - R * math.sin(angle + math.pi/2)'''\n                u = midpoint[0]\n                v = midpoint[1]\n                b = coordinates[j][1] - coordinates[i][1]\n                a = coordinates[j][0] - coordinates[i][0]\n                if a*b < 0:\n                    x_p1 = u + math.sqrt((R*R-(a*a+b*b)/4)*b*b/(a*a+b*b))\n                    y_p1 = v + math.sqrt((R*R-(a*a+b*b)/4)*a*a/(a*a+b*b))\n\n                    x_p2 = u - math.sqrt((R*R-(a*a+b*b)/4)*b*b/(a*a+b*b))\n                    y_p2 = v - math.sqrt((R*R-(a*a+b*b)/4)*a*a/(a*a+b*b))\n                else:\n                    x_p1 = u - math.sqrt((R*R-(a*a+b*b)/4)*b*b/(a*a+b*b))\n                    y_p1 = v + math.sqrt((R*R-(a*a+b*b)/4)*a*a/(a*a+b*b))\n\n                    x_p2 = u + math.sqrt((R*R-(a*a+b*b)/4)*b*b/(a*a+b*b))\n                    y_p2 = v - math.sqrt((R*R-(a*a+b*b)/4)*a*a/(a*a+b*b))\n\n                if 0 <= x_p1 <= W and 0 <= y_p1 <= H:\n                    unique_positions.add((x_p1, y_p1))\n                    #print((x_p1, y_p1), (i, j), get_distances((x_p1, y_p1), coordinates[i]))\n                if 0 <= x_p2 <= W and 0 <= y_p2 <= H:\n                    unique_positions.add((x_p2, y_p2))\n                    #print((x_p2, y_p2), (i, j), get_distances((x_p2, y_p2), coordinates[i]))\n\n    for i in range(len(coordinates)):\n        if check[i] == 0: \n            unique_positions.add((coordinates[i][0], coordinates[i][1]))\n            #print((coordinates[i][0], coordinates[i][1]), i)\n    \n    targetted = []\n    for i in range(len(list(unique_positions))):\n        temp = []\n        targetted.append(temp)\n\n    for i in range(len(list(unique_positions))):\n        for j in range(len(coordinates)):\n            #if j == 0: print(get_distances(list(unique_positions)[i], coordinates[j]), list(unique_positions)[i])\n            if get_distances(list(unique_positions)[i], coordinates[j]) <= R + deltaR:\n                #print(i, j)\n                targetted[i].append(j)\n    \n    a = []\n    for j in range(len(coordinates)):\n        temp = [0]*len(list(unique_positions))\n        a.append(temp)\n\n    for j in range(len(coordinates)):\n        for i in range(len(list(unique_positions))):\n            if j in targetted[i]:\n                a[j][i] = 1\n    \n    return list(unique_positions), a\n\n\n"
                },
                {
                    "name": "main.py",
                    "type": "MODIFY",
                    "added": 2,
                    "deleted": 23,
                    "loc": 97,
                    "source": "import data\nimport simplex_method\nimport queue\nimport math\nimport numpy as np\nimport copy\n\nimport matplotlib.pyplot as plt\nfile_name_csv = \"Data/N=20_W=30_H=40_normal_0.csv\"\n\nT = [] #Target\nQ = [] #Demand\nI = [] #Target isolated\nP = [] #Good position for placing sensors\nx = [] #Number of sensors in P\na = [] #Sensor j cover by position P_i\nT, Q = data.read_data(file_name_csv)\n\nP, a = data.find_positions(T)\nc = [1]*len(P)\nepsilon = (-1)*0.000001\n\ndef isInteger(x):\n    for i in range (len(P)):\n        if not float(x[i]).is_integer():\n            index = i\n            return False, index\n    return True, None\n\ndef create_subproblem(A, b, c, solution):\n    index = isInteger(solution)[1]\n    floor_constraint = np.zeros(len(P))\n    floor_constraint[index] = 1\n\n    subproblem_floor = {\n        'A': np.vstack([A, floor_constraint]),\n        'b': np.concatenate([b, [int(solution[index]) + 1]]),\n        'c': c\n    }\n\n    ceil_constraint = -floor_constraint\n    subproblem_ceil = {\n        'A': np.vstack([A, ceil_constraint]),\n        'b': np.concatenate([b, [-int(solution[index])]]),\n        'c': c\n    }\n\n    return subproblem_floor, subproblem_ceil\n\ndef branch_and_bound(A, b, c):\n    q = queue.Queue()\n    iteration = 1e6\n    best_value = 1e6\n    best_solution = []\n    initial_problem = {'A': A, 'b': b, 'c': c}\n    q.put(initial_problem)\n    while not q.empty():\n        current_problem = q.get()\n        flag, current_solution, current_value = simplex_method.simplex_method1(current_problem['A'], current_problem['b'], current_problem['c'])\n        # print(flag, current_solution)\n        if not flag: continue\n        if isInteger(current_solution)[0]:\n            if current_value - best_value < epsilon:\n                best_solution = copy.deepcopy(current_solution)\n                best_value = current_value\n        else:\n            if current_value - best_value < epsilon:\n                subproblem_floor, subproblem_ceil = create_subproblem(current_problem['A'], current_problem['b'], current_problem['c'], current_solution)\n                q.put(subproblem_floor)\n                q.put(subproblem_ceil)\n        #print('---------',iteration, '-----------')\n        # print(current_value)\n        # print(current_solution)\n        #iteration -=1\n    \n    if best_solution == []:\n        return False, None, None\n    return True, best_solution, best_value\n\nflag, x,  optimal_solution = branch_and_bound(a, Q, c)\n\ndef convert_output(x):\n    output = []\n    for i in range(len(P)):\n        if x[i] != 0:\n            output.append((P[i], x[i]))\n    \n    return output\n\noutput = convert_output(x)\nif flag:\n    for i in range(len(output)):\n        print(\"Number of sensors in P\",output[i][0],\" is \", int(output[i][1]))\n    \n    print(\"Total sensors: \", int(optimal_solution))\n# Create a new figure with specified size\nplt.figure(figsize=(data.W, data.H))\n\n# Set x-axis and y-axis limits based on W and H\n\n\nfor i in range(len(output)):\n    center = np.array(output[i][0])\n    theta = np.linspace(0, 2*np.pi, 100)\n    x = (data.R+data.deltaR) * np.cos(theta) + center[0]\n    y = (data.R+data.deltaR) * np.sin(theta) + center[1]   \n    plt.plot(x, y, color = 'blue')\n    if i == 0:\n        plt.scatter(center[0], center[1], color='red', label = 'Sensors')\n    else:\n        plt.scatter(center[0], center[1], color='red')\n\nfor i in range(len(T)):\n    if i == 0:\n        plt.scatter(T[i][0], T[i][1], color='green', marker='*', label = 'Targets')\n    else:\n        plt.scatter(T[i][0], T[i][1], color='green', marker='*')\n\nplt.axis([0, data.W, 0, data.H])\nplt.gca().set_aspect('equal', adjustable='box')\nplt.legend()\nplt.xlabel('X-axis')\nplt.ylabel('Y-axis')\nplt.show()"
                },
                {
                    "name": "simplex_method.py",
                    "type": "MODIFY",
                    "added": 61,
                    "deleted": 29,
                    "loc": 109,
                    "source": "import numpy as np\nimport time\n\ndef convert(A, b, c, Q0):\n    A = np.array(A)\n    m, n = A.shape\n\n    # Add slack variables\n    slack_variables = np.eye(m)\n    A_extended = np.hstack((A, slack_variables))\n    c_extended = np.concatenate((c, np.zeros(m)))\n\n    # Add surplus variables\n    surplus_variables = np.eye(m)\n    A_surplus = np.hstack((A, surplus_variables))\n    XB = []\n    for i in range (m):\n        XB.append(len(c_extended)-m+i)\n    tableau = np.vstack((np.hstack((np.zeros(1), -c_extended, 0)), np.column_stack((b, A_surplus, Q0*np.ones(m)))))\n    return tableau\n\ndef update_tableau(tableau, basis):\n    new_tableau = []\n    \n    for row_idx in range(len(basis) + 1):\n        local_tableau = tableau[:]\n        local_basis = basis[:]\n        m = local_tableau[row_idx]\n        rows = np.delete(local_tableau, row_idx, 0)\n        \n        if row_idx > 0:\n            cur_intersection_value = m[local_basis[row_idx - 1]]\n            del local_basis[row_idx - 1]\n        \n        if all(m[local_basis] == 0) and row_idx > 0:\n            new_row = m / cur_intersection_value\n        else:\n            for row in rows:\n                e = [e for e, i in enumerate(m[local_basis]) if i != 0]\n                c = - m[local_basis][e] / row[local_basis][e]\n                new_row = m + c * row\n                \n                if all(new_row[local_basis] == 0):\n                    break\n        \n        new_tableau.append(new_row)\n                \n    return np.array(new_tableau)\n\ndef simplex_method(A, b, c, Q0):\n        \n    tableau = convert(A, b, c, Q0)\n\n    while np.any(tableau[0, 1:] < 0):\n        pivot_col = np.argmin(tableau[0, 1:]) + 1\n\n        ratios = np.where(tableau[1:, pivot_col] > 0, tableau[1:, 0] / tableau[1:, pivot_col], np.inf)\n\n        if np.all(ratios == np.inf):\n            return False, None, None\n\n        pivot_row = np.argmin(ratios) + 1\n\n        pivot = tableau[pivot_row, pivot_col]\n\n        tableau[pivot_row, :] /= pivot\n\n        tableau = update_tableau(tableau, pivot)\n        \n        for i in range(tableau.shape[0]):\n            if i != pivot_row:\n                tableau[i, :] -= tableau[i, pivot_col] * tableau[pivot_row, :]\n\n    optimal_solution = tableau[1:, 0]\n    optimal_value = tableau[0, 0]\n\n    return True, optimal_solution, optimal_value\n\nfrom scipy.optimize import linprog\n\ndef simplex_method1(a, Q, c):\n    A = -1 * np.array(a) \n\n    b = -1 * np.array(Q) \n    Q0 = max(Q)\n    # Bounds for variables\n    x0_bounds = (0, Q0)\n    bounds = [x0_bounds] * len(c)\n\n    # Solve the linear programming problem\n    result = linprog(c, A_ub=A, b_ub=b, bounds=bounds, method='highs')\n\n    if result.success:\n        optimal_solution = [round(x, 6) for x in result.x]\n        optimal_value = round(result.fun, 6)\n    else:\n        optimal_solution = None\n        optimal_value = None\n\n    return result.success, optimal_solution, optimal_value\n\n'''test = {'A': np.array([[ 1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  0.,  0.,  0.,  0.,  0.,\n         0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  1.,  0.,  0.,\n         1.,  0.,  0.,  0.,  0.,  1.,  0.,  0.,  0.,  1.,  1.],\n       [ 1.,  1.,  1.,  0.,  0.,  0.,  0.,  0.,  1.,  1.,  1.,  1.,  1.,\n         1.,  0.,  0.,  0.,  1.,  0.,  0.,  0.,  0.,  0.,  1.,  0.,  0.,\n         1.,  0.,  0.,  0.,  0.,  1.,  0.,  0.,  0.,  1.,  0.],\n       [ 0.,  0.,  1.,  0.,  0.,  0.,  0.,  0.,  1.,  1.,  0.,  0.,  0.,\n         0.,  1.,  1.,  1.,  1.,  1.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,\n         0.,  0.,  0.,  0.,  0.,  0.,  1.,  1.,  0.,  0.,  1.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  1.,  0.,  0.,  0.,\n         0.,  1.,  0.,  0.,  0.,  0.,  1.,  1.,  1.,  0.,  0.,  0.,  0.,\n         0.,  0.,  1.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  1.,  0.,  0.,  0.,  0.,  0.,  1.,  0.,  0.,  0.,\n         0.,  0.,  1.,  0.,  0.,  0.,  1.,  0.,  0.,  1.,  1.,  1.,  1.,\n         0.,  0.,  0.,  0.,  0.,  0.,  1.,  0.,  0.,  0.,  1.],\n       [ 0.,  0.,  0.,  1.,  1.,  1.,  1.,  0.,  0.,  0.,  1.,  1.,  1.,\n         1.,  0.,  0.,  1.,  1.,  1.,  0.,  1.,  1.,  1.,  1.,  0.,  1.,\n         1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  0.,  1.,  1.],\n       [ 1.,  0.,  1.,  0.,  0.,  0.,  1.,  0.,  0.,  0.,  0.,  1.,  1.,\n         0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  1.,  0.,\n         1.,  1.,  0.,  0.,  0.,  0.,  0.,  1.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  1.,  0.,  0.,  1.,  1.,  1.,  1.,  0.,  0.,  0.,\n         1.,  0.,  0.,  0.,  1.,  0.,  0.,  1.,  1.,  1.,  0.,  0.,  1.,\n         0.,  0.,  1.,  1.,  0.,  0.,  1.,  1.,  1.,  1.,  1.],\n       [ 0.,  1.,  0.,  1.,  1.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,\n         0.,  0.,  0.,  0.,  0.,  1.,  1.,  0.,  1.,  1.,  0.,  0.,  0.,\n         0.,  1.,  0.,  1.,  1.,  0.,  0.,  0.,  1.,  1.,  1.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,\n         0.,  1.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,\n         0.,  0.,  0.,  0.,  0.,  1.,  1.,  0.,  0.,  0.,  1.],\n       [-0., 1., -0., -0., -0., -0., -0., -0., -0., -0., -0., -0., -0.,\n        -0., -0., -0., -0., -0., -0., -0., -0., -0., -0., -0., -0., -0.,\n        -0., -0., -0., -0., -0., -0., -0., -0., -0., -0., -0.]]), \n        'b': np.array([5, 1, 3, 5, 5, 3, 3, 2, 1, 4, 1]), \n        'c': [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], \n        'Q0': 5}\nprint(len(test['A'][0]))\nflag, optimal_solution, optimal_value = simplex_method(test['A'], test['b'], test['c'], test['Q0'])\nprint(flag)\nprint(optimal_solution)\nprint(optimal_value)'''"
                }
            ],
            "parents": [
                "ea0548da1880a08d37baf1a188dc2eeca63aac8f"
            ]
        },
        {
            "sha": "dbca0c122488fa47dabb9fa3a2e386440c1129ba",
            "committer": "Grizzlazy",
            "msg": "Update README.md",
            "date": "01/07/24T22:18:08",
            "modified_files": [],
            "parents": [
                "748fed39c35e28a6246abf7c323a769d71bf1c6d"
            ]
        }
    ]
}